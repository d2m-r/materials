[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "From Data to Manuscript in R",
    "section": "",
    "text": "Preface\nThis is an in-development textbook for the course “From Data to Manuscript in R” offered at the University of Chicago. At this point, you shouldn’t be seeing this at all. If you are not me, I’m really not sure why you’re here, tbh. Go look at real books like R for Data Science.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#outline",
    "href": "index.html#outline",
    "title": "From Data to Manuscript in R",
    "section": "Outline",
    "text": "Outline\nBased on current slides\n\nQuarter 1\n\nIntroduction\n\nPSYC 30550 D2MR - Overview\n\nThe class itself - link to course page\nAssessment structure\n\nD2MR Workflow\nThis book\n\nThe goals\nHow to use it\nHow to contribute\n\nGetting Started/Setting up (in the form of walking through a dummy repo)\n\nDownload and install R and RStudio\nGet familiar with RStudio\nR Notebooks\n\nPreview quarto\n\nGet Git\nConnect RStudio to GitHub\n\n(Optional) Set up Copilot in RStudio\n\nSolving Problems\n\nIntroduction - why this is a whole section’\nUsing AI\nBest practices - keep your code:\n\nStandardized\nIntelligible\nMaintainable\nContextualized\n\nDebugging & Troubleshooting\n\nDocumentation\n\nHelp/lookup functions\nFunction documentation\nPackage documentation\nResources\n\nSolving your own problems\n\nError messages\nGarbage in, garbage out (and other tropes)\nLine-by-line debugging\nRubber ducking\n\nAsk the internet\n\nStart strong - asking good questions\nCrowdsource\nUse AI constructively\n\nAsk humans – for D2MR Students\n\nAsk your classmates\nUse Slack\nAsk your instructor & TAs\nThe D2MR troubleshooting process\n\nStarting from “Nothing”\n\n\nRStudio Essentials\n\nRStudio\n\nOverview + what’s an IDE\nLayout\n\nSource pane\nConsole pane\nThe rest of the panes\n\nEnvironment\nHistory\nFiles\nPlots\nConnections\nPackages\nHelp\nBuild\nVCS\nTutorial\nViewer\nPresentations\n\n\n\nKeyboard shortcuts\nCustomizing RStudio\nFile types - just a preview, we’ll cover these in more detail later!\n\n.Rmd\n.qmd\n.R\n.Rproj\nLots of metadata files you can mostly ignore (including literally in your .gitignore)\n\n.Rhistory\n.RData\n.Rprofile\n.Rproj.user\n\n\n\nGit & GitHub Essentials\n\nIntroduction – the point of version control\nGit\n\nOverview & workflow musts\nGit lingo\n\nRepositories\n\nrepository / repo\ninitialize\nclone\nbranch & checkout\n\nVersion control\n\ncommit\nstage\nfetch\npull\npush\n\nMerging\n\ndiff\nmerge\nmerge conflict\nrebase\nfast-forward (ff)\nsquash\ncherry-pick\nstash\n\nRemote repositories\n\nremote\norigin\nupstream\nfork\npull request\n\n(Optional) Using Git in the terminal\n\n\nRepo structure\n\nWhat does and does not go in a repo?\nTop-level essentials\n\nREADME\n.gitignore\n\nThe rest of your stuff\nMetadata and information\n\nGitHub\n\nWhat is GitHub? How is it different from Git?\nGitHub features\n\nIssues\nPull requests\nPages\nCopilot\nMore\n\nActions\nProjects\nCodespaces\n\n\nInterfacing with GitHub (without RStudio)\n\nGitHub website\nGitHub Desktop\nOther options\n\nVS Code and other IDEs\nGitHub CLI\n\n\nInterfacing with GitHub in RStudio\n\nConnecting RStudio to GitHub\nUsing GitHub in RStudio\n\nCloning a repo\nCommitting changes\nPushing changes\nPulling changes\nCreating pull requests\n\n\n\nGit Pains\n\nCommon issues\nHelpful resources\nThe nuclear option\n\n\nR Language Essentials\n\nIntroduction\n\nWhat is R and why use it?\nObject-oriented programming\n\nR syntax\n\nVariables\nFunctions\nData types\nOperators\n\nR data structures\n\nVectors\nLists\nMatrices\nData frames\nTibbles\n\nR packages\n\nWhat are packages?\nInstalling and loading packages\nSame function, different packages, oh no!\n\nFunctions with different names in different packages that all do the same thing\nFunctions with the same name in different packages that do different things\n\nCommonly used packages in D2MR\n\n\nR Programming\n\nEssential concepts in base R\n\nObject assignment\n\nCreating dummy variables and dataframes\n\nIndexing and subsetting with [] & $\n(more base R essentials)\n\nIteration\n\nConditional statements\n\nif else\ncase_when\n\nLoops\n\nfor loops\nwhile loops\n\n\nFunctions in R\n\nWriting functions\nFunction arguments and return values\nScope and environments\n\nRegular expressions\n\nWhat is regex? What’s the point?\nBasic syntax\nCommon use cases\n\n\nWelcome to the Tidyverse!\n\nIntroduction to the Tidyverse & tidy data\n\nOverview of the tidy ecosystem\nTidy data principles\nCore packages in the Tidyverse and general functions\nTerminology\n\nImporting and exporting with readr\n\nOverview\n\nTabular data - what counts?\n\nFile types\nR objects, including tibbles\n\nReading, writing, rereading (intermediate datasets)\n\nReading data with read_* functions\nWriting data with write_* functions\nOther packages\n\nreadxl for Excel files\nhaven for SPSS, SAS, and Stata files\ngooglesheets4 for Google Sheets\njsonlite for JSON files\nDBI and dbplyr for databases\n\nHandling common import/export issues\n\nData manipulation with dplyr\n\nIntroduction to dplyr\n\nthe points of pipelines (highly readable, but verbose)\nThe pipe operator (%&gt;%) and magrittr\nChaining operations with pipes\n\nSelecting data\n\nselect, rename\nfilter\narrange\n\nManipulating data\n\nmutate\nsummarize\ngroup_by\ndistinct\ncount\n\ndplyr practice\n\nData tidying with tidyr\n\nWhat counts as “tidying” data?\n\nRemember what “tidy” means in the tidyverse\nTidying is reshaping and systematically cleaning data\n\nReshape data\n\npivot_longer\npivot_wider\ncast, melt, gather, spread, etc.\n\nCombine and split cells\n\nunite\nseparate functions\n\nExpand tables\n\nexpand\ncomplete\n\nHandle missing values\n\ndrop_na\nfill\nreplace_na\n\nAdvanced: Nested data\n\nWhat is nested data and why might you use it?\nWe’re not going to cover this in D2MR, but tidyr has functions for creating, reshaping, and transforming nested data\n\n\n\nWorking with different data types in the tidyverse\n\nWhy specialized packages exist for text, factors, and dates\n\nBase R can do this stuff, but it’s not always great\nTidyverse functions are useful:\n\nConsistent syntax\nMore intuitive functions\nMore intuitive pattern matching (stringr)\nSeamlessly compatible with dplyr, tidyr, and the rest of the tidyverse\n\n\nText data with stringr\n\nOverview\n\nRemember what strings and character vectors are?\nRemember what regex is?\nSpecial things about strings (using quotes, escaping characters, etc.)\nBase R can do string stuff - Useful base R string functions\n\npaste & paste0\nc\ntoupper, tolower\nis.character\ntoString\nPattern matching with grep family\n\n\nMatch strings\n\nstr_detect\nstr_starts\nstr_ends\nstr_count\n\nSubsetting and length\n\nstr_sub\nstr_subset\nstr_length\nstr_pad\nstr_trunc\nstr_trim\n\nMutate, join, split\n\nstr_sub (again)\nstr_replace, str_replace_all\nstr_remove, str_remove_all\nstr_to_lower, str_to_upper, str_to_title\nstr_split\nstr_c, str_glue\nstr_flatten\n\n\nFactors with forcats\n\nOverview\n\nWhat are factors?\nThey look like strings, how are they different? Why do we have to have a whole separate package for them?\n\nLevels\nOrder\nClosed set\n\n\nBase R can do factor stuff (and unlike with strings, you’ll use these base R factor functions a lot!)\n\nfactor\nlevels\nrelevel\nother base factor functions are mostly variations on these\n\nUseful forcats functions\n\nfct_relevel\nfct_reorder\nfct_rev\nfct_recode\nfct_collapse\nfct_other\nfct_drop\nfct_expand\n\n\nDates and times with lubridate \n\nOverview\n\nWhat are dates and times?\nWhy do we need a whole package for them?\nBase R can do date and time stuff, but it’s not great\n\nas.Date\nas.POSIXct\nas.POSIXlt\nstrptime\n\n\nlubridate functions\n\nParsing dates and times\n\nymd, mdy, dmy, ymd_hms, etc.\nparse_date_time\n\nExtracting components\n\nyear, month, day, hour, minute, second\nwday, yday, mday\n\nManipulating dates and times\n\n%m+% and %m-% for adding and subtracting time\ninterval and duration\nfloor_date, ceiling_date, round_date\n\nFormatting dates and times\n\nformat\nstrftime\n\n\n\n\nBasic visualization and summary statistics\n\nThis chapter is not the ggplot2 chapter or a deep stats chapter. It’s a connection between the two quarters of the class.\nPutting things together\n\nhow data manipulation in the tidyverse leads to easier visualization\nhow visualization leads to better understanding of your data\nhow visualization and summary statistics fit together\n\nDistributions of continuous variables\n\nHistograms\nBox plots\nSummary statistics: mean, median, variance, standard deviation\n\nComparing groups\n\nBar plots\nSummary statistics: grouped means, medians, etc.\nt-tests\nMore advanced for later: ANOVA, chi-squared tests\n\nRelationships between continuous variables\n\nScatter plots and smoothing lines\nCorrelation\nBasic linear regression\nMore advanced for later: Multiple regression, logistic regression\n\n\nMidpoint review\n\n\n\nQuarter 2\n\n\nAppendix\n\nGlossary\nReferences",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "chapters/intro.html",
    "href": "chapters/intro.html",
    "title": "1  Introduction to D2M-R - TEST EDIT 2",
    "section": "",
    "text": "1.1 PSYC 30550 D2MR - Overview",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to D2M-R - TEST EDIT 2</span>"
    ]
  },
  {
    "objectID": "chapters/intro.html#psyc-30550-d2mr---overview",
    "href": "chapters/intro.html#psyc-30550-d2mr---overview",
    "title": "1  Introduction to D2M-R - TEST EDIT 2",
    "section": "",
    "text": "1.1.1 The class itself - link to course page\n\n\n1.1.2 Assessment structure",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to D2M-R - TEST EDIT 2</span>"
    ]
  },
  {
    "objectID": "chapters/intro.html#d2m-r-workflow",
    "href": "chapters/intro.html#d2m-r-workflow",
    "title": "1  Introduction to D2M-R - TEST EDIT 2",
    "section": "1.2 D2M-R Workflow",
    "text": "1.2 D2M-R Workflow",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to D2M-R - TEST EDIT 2</span>"
    ]
  },
  {
    "objectID": "chapters/intro.html#this-book",
    "href": "chapters/intro.html#this-book",
    "title": "1  Introduction to D2M-R - TEST EDIT 2",
    "section": "1.3 This book",
    "text": "1.3 This book\n\n1.3.1 The goals\n\n\n1.3.2 How to use it\nIf you’re coming at this book as a total beginner, it’s going to get overwhelming at times. This is just the nature of how programming works, since everything is deeply interconnected.\nThink about the difference between learning your native language as a baby and learning an additional language in school. With your second language, you already have a lot of the foundational concepts in place. You can map new words to old word, new structures to old structures. You already have clear communicative goals, you know how to tell whether your attempts at communication are successful, and you can interpret feedback and corrections when something goes wrong.\nWhen you learned your first language, you just…did it. At some baby-level, you had things you wanted to communicate, but you didn’t have the words or grammar to do it. You didn’t even have a non-language internal model of the message. At some point in acquisition, you recognize in your baby way that there is a system that can help you out, and you pick up patterns and rules from the sea of incomprehensible input around you.\nIf you have never programmed before, you are the baby here. (No shade to either you or babies. Language learning is extremely wild and cool.) You’re going to need to give yourself some grace. Pick up on the patterns and rules where you can, knowing that everything is here to come back to when you’re able to build on your existing knowledge.\nIn an effort to help you out, throughout this book I’ve included some simplistic points of what you need to know now based on what I know is coming up in the course. When you see WYNTKN (What You Need To Know Now), know that stuff now before you move on. Bear in mind that often those points will be presented in an oversimplified way that doesn’t tell the whole story, but that’s kind of the point.\nOn the other end of the spectrum, you may be coming at this course with some – or even a lot – of experience with programming in Python, running stats in Stata or SPSS, using git and GitHub for version control, etc. You may even be a seasoned R programmer who is looking to brush up on some skills or fill in gaps. In D2M-R, you’ll be an invaluable support for your classmates (which is part of your grade). You’ll be able to skim the basics and focus on the parts that are new to you. If you know clearly what your goals are, you might have some things you want or need to know that we won’t cover in this introductory course. At the end of (most) sections, I’ve included a Learn More section with links to resources for further reading that should help you independently go further. If there is a topic you want to learn more about that isn’t covered here, please reach out to me and I can help you find resources and add them to the book.\n\n\n1.3.3 How to contribute\n\n\n1.3.4 What this course is not\n\nMac/Windows bilingual. Because the vast majority of students use Macs (as do I), some details are Mac-specific. Translating to Linux is going to be pretty trivial for anyone who is already a Linux user. Translating to Windows isn’t always immediately obvious, but it is well-documented and should be pretty straightforward with common sense and minimal googling.\nComprehensive. This is an introductory course. We’re going to skip a lot of details and edge cases in the interest of getting you up and running as soon as possible. Some things that do make it in will be oversimplified. If you want to go deeper, check out the Learn More sections in each chapter, as well as the Resources page.\nInfallible and beyond reproach. There will be mistakes, and there will be things that could be explained better. Keep in mind that I am not a computer scientist, and my work rarely requires deep, theoretical programming knowledge. What I am is an academic and an educator, which means I love an opportunity to learn something new. In my classrooms I teach that the most important skill to have in academia1 is learning to say “I don’t know” and “I was wrong.” There are times where I learned something incorrectly, where my knowledge is out of date, or where the best way I know to do something is absurdly overcomplicated. If you see something that seems wrong, please reach out to me so I can fix it. You’re doing me a personal favor by teaching me something new! Even if you have misunderstood and I’m “right,” I will learn that I have explained it poorly and figure out a better way to do so.\nA statistics or experimental design text. We’ll cover some basic descriptive stats in the first half of the course. In the second half, we’ll cover some of the inferential stats that are most commonly used in psychology. When I say “cover,” I mean we’re going to give you the tools to execute these analyses in R. We will touch on what kinds of scenarios social scientists use these analyses in, but we will not go into the theory or assumptions behind them. It is your job to learn how to make good decisions about which analyses to use when, and how to thoughtfully and productively interpret your results.\nA programming text. I mean, yes, obviously it teaches programming, but it’s extremely applied. This is a text about how to do what you need to do with R as a critical tool. Hopefully many of the skills you come away with will be transferable to other programming languages, but this isn’t going to teach you how to program in a language-agnostic way.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to D2M-R - TEST EDIT 2</span>"
    ]
  },
  {
    "objectID": "chapters/intro.html#getting-startedsetting-up",
    "href": "chapters/intro.html#getting-startedsetting-up",
    "title": "1  Introduction to D2M-R - TEST EDIT 2",
    "section": "1.4 Getting Started/Setting up",
    "text": "1.4 Getting Started/Setting up\n\n\n1.4.1 Download and install R and RStudio\n\n\n1.4.2 Get familiar with RStudio\n\n\n1.4.3 R and Quarto Notebooks\n\n\n1.4.4 Get Git\n\n\n1.4.5 Connect RStudio to GitHub\n\n\n1.4.6 (Optional) Set up Copilot in RStudio",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to D2M-R - TEST EDIT 2</span>"
    ]
  },
  {
    "objectID": "chapters/intro.html#footnotes",
    "href": "chapters/intro.html#footnotes",
    "title": "1  Introduction to D2M-R - TEST EDIT 2",
    "section": "",
    "text": "Or, I’d argue, in life.↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to D2M-R - TEST EDIT 2</span>"
    ]
  },
  {
    "objectID": "chapters/solving-problems.html",
    "href": "chapters/solving-problems.html",
    "title": "2  Solving (Your Own) Problems",
    "section": "",
    "text": "3 Overview\nWhy is this its own chapter?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Solving (Your Own) Problems</span>"
    ]
  },
  {
    "objectID": "chapters/solving-problems.html#standardized",
    "href": "chapters/solving-problems.html#standardized",
    "title": "2  Solving (Your Own) Problems",
    "section": "4.1 Standardized",
    "text": "4.1 Standardized\nR is a pretty forgiving language. It’s whitespace insensitive (in case you don’t already believe the tabs vs spaces debate is irrelevant) and has relatively few forbidden characters or “arbitrary” syntax constraints. If you break a rule you get an error, which is a lot nicer than if it were to just run anyway and produce mysterious, inexplicable results.\nThis has a lot of advantages, but one downside is that your code can get extremely messy before things actually start to break. You can write perfectly functional R code that is utterly indecipherable to humans, including you-the-coder. Standardizing styling decisions helps keep things organized and human-friendly.\n\n4.1.1 Style guides\nCoding style guides serve the same functions as publication style guides, like AP Style or the New York Times manual of style. They demand (or at least encourage) consistency, which should make things more comprehensible for you and your “readers” (collaborators).\nAn effective and comprehensive style guide for R programming will establish conventions for naming objects and functions, handling whitespace and punctuation, and preferred syntax or representations (e.g., a rule to use the &lt;- assignment operator rather than =). It will also usually contain guidelines for otherwise highly subjective things like how to structure comments, how verbose function definitions should be, how to clearly construct error messages, and the necessary elements and formatting of documentation.\nThe tidyverse style guide is an excellent, comprehensive, and widely used style guide for R. If you don’t already have a preferred style guide, I suggest starting here.\n\n\n4.1.2 Internal consistency\nThe best style guide is the one you can stick to. So long as (1) it functions within your environment (no matter how much you’d like to begin your variable names with numerals, it’s not a style option) and (2) it’s comprehensible (for you totally and to others generally), the internal consistency is what really matters.\nPay attention to how you manage to adhere to your style as you code. Are there guidelines you can’t seem to remember or always mess up? Are there things that just confuse you? Do you look back on your code that perfectly follows your style and forget why you styled certain things the way you did? These are most likely to be the breaking points for internal consistency. If some aspect of style isn’t helping your code be more comprehensible and more efficient to review and maintain, it’s counterproductive and you should change to something that will be more helpful.\nFor example, the tidyverse style guide recommends using underscores when naming all objects. I find that using underscores for everything leads me to mix up different kinds of objects. Is child_gesture the name of the dataframe with gesture-level coding or the column in that dataframe that contains frequency of children’s gestures? Is shrug_bar_plot the modified dataframe that is piped into a ggplot object, the ggplot object itself, the chunk name where the plot is defined, the chunk where it’s rendered, or something else?\nIt would be great if I was good enough at giving objects informative names (see below!) to not confuse myself with this style, but realistically it doesn’t work for me. Instead of using underscore separators for everything, I opt to use periods for “complex” objects like dataframes, underscores for “simple” or “internal” objects like variables, camel-case for “publishable” objects like plots, and hyphens for “containers” like chunk and file names. Some people would find my system infuriating for any number of reasons, but over time I’ve found it works for me. Since I can be consistent with it, it really speeds up coding and debugging, and it doesn’t actively impede comprehensibility for others. That’s ultimately what matters.\nYou can view the custom style guide I (usually) follow here. Remember this is just what I have found works well for me. It’s not “correct” and you don’t have to use it!\n\n4.1.2.1 Styling tools\nThere are (at least) two well-maintained packages that can help you enforce style guides: lintr and styler. Both use tidyverse style by default, but are customizable to your preferred style rules.\n\n\n4.1.2.2 Final notes on styling\nWhile standardizing your coding style is an essential “best practice,” remember that in the end styling is usually not make-or-break for your code. Don’t get lost in the weeds. Again: The best code is the code that works. You have limited time and energy to work on your project. Before you get too deep into developing your own personalized style or rigorously checking every detail of every script you’ve ever written to retroactively enforce a style, think about whether that’s truly the most productive use of your precious time. Hopefully at some point style really can be high priority, but if that’s not where you’re at right now, that’s fine!\n\n\n\nC Programming Style Guide Cartoon – “I hate programmers.”\n\n\nOne final recommendation: choose where to be cautious. It’s easy to avoid special characters even if they’re technically permissible sometimes, so just avoid them. Being concise is nice, but it’s probably safer to prioritize readability over conciseness. Keep your future self in mind. What can you do now to best help future-you when you come back to this project in a year having completely forgotten everything you’re doing now?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Solving (Your Own) Problems</span>"
    ]
  },
  {
    "objectID": "chapters/solving-problems.html#example-my-style-guide-and-practices",
    "href": "chapters/solving-problems.html#example-my-style-guide-and-practices",
    "title": "2  Solving (Your Own) Problems",
    "section": "4.2 Example: My style guide and practices",
    "text": "4.2 Example: My style guide and practices\nYou can view the custom style guide I (usually) follow here. Remember this is just what I have found works well for me. It’s not “correct” and you don’t have to use it!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Solving (Your Own) Problems</span>"
    ]
  },
  {
    "objectID": "chapters/solving-problems.html#intelligible",
    "href": "chapters/solving-problems.html#intelligible",
    "title": "2  Solving (Your Own) Problems",
    "section": "4.3 Intelligible",
    "text": "4.3 Intelligible\n\n4.3.1 Informative comments\nComments are an essential but easily overlooked part of your code. If you’re a beginner coder, commenting may feel burdensome, compounded by the fact that beginner coders should practice over-commenting to an extent (and chill out a bit as they gain experience). Fight the impulse to treat commenting as busy work or an unpleasant obligation. Comments are a critical tool for making something designed to be comprehensible to a machine equally comprehensible to the humans who actually have to do the work of designing and maintaining it.\n Borrowing from this stackoverflow blog post, here are 9 rules for effective commenting:\n\nComments should not duplicate the code.\nGood comments do not excuse unclear code.\nIf you can’t write a clear comment, there may be a problem with the code.\nExplain unidiomatic code in comments.\nProvide links to the original source of copied code.\nInclude links to external references where they will be most helpful.\nAdd comments when fixing bugs.\nUse comments to mark incomplete implementations.\n\nCheck out the original post for more information on what each of these rules means. The biggest picture take-aways should be that 1) comments are not optional and 2) the code tells you how, the comments tell you why.\nIt’s also worth pointing out that if you choose to use Copilot when coding in RStudio, writing good comments is what prompts useful code suggestions that are actually in line with what you want.\n\n4.3.1.1 Commit messages\nAs you get used using github, think about your commit messages as the cousin of in-text comments. Your commit messages should be informative, clear, and concise. Your repo is a living thing (that’s the point!) and by the time you’re ready to never look at this thing ever again you’ll have committed a million changes. Your commit messages should tell that version of you exactly what the purpose of each commit was.\nImagine you are starting a project 3 years from now. Future-you knows that present-you wrote exactly the code you need at the beginning of present-you’s project, but by the end of this project that code was irrelevant and so (rightfully) removed from the “final” version. Future-you looks through the messages, find “Deleted chunk that calculates ratio of giant ducks to tiny dinosaurs in a fair fight,” and is indescribably grateful to present-you for writing clear commit messages.\nMore on commit messages in Chapter 5.\n\n\n4.3.1.2 Final note on comments\nPersonally, I don’t mind humorous comments or commit messages. I actively endorse them as a way to let things go, keep your priorities straight, vent frustration, seek some solidarity, and give future-you a chuckle. That said, not everyone appreciates overly casual commenting. Be mindful of keeping your comments professional if that’s what your context expects. (Please feel free to let your geek humor flag fly in D2M-R. I always appreciate the occasional “I have no idea why this works but for the love of god don’t change it.”)\n\n\n\nGood comments are hard. – Geek and Poke\n\n\n\n\n\n4.3.2 Meaningful naming\nFor some reason every example in every programming tutorial ever will teach you how to create a variable with the name my_variable and a function with the name my_function. I get it, but these are objectively horrible names. Imagine looking through someone’s code and seeing my_function(my_variable, 2). What?? That better come with like 12 lines of comments because otherwise it’s total nonsense.\nOf course, no one actually recommends using my_whatever in your actual code, but it’s the principle of the thing! Designing object, function, and file names that actually tell you any useful information can be a lot harder than it sounds, but it’s essential for the intelligibility of your code.\n\n“There are only two hard things in Computer Science: cache invalidation and naming things.”\n— Phil Karlton\n\nThe big rule here (vs a guideline): Names should describe the named thing.\n A few guidelines for crafting meaningful names (source):\n\nAvoid disinformation. Don’t include _df in the name of a data.table, don’t name a function get_number if it returns a string.\nUse pronounceable names. Whether you want to or not you’ll inevitably talk about your code out loud (even if just to a rubber duck). It’s a lot easier to ask someone to check for errors in your child_gesture table or your group_SES_quartile function than cgtbl or grpsq. This doesn’t mean you can’t abbreviate: chi_gest and SES4 are perfectly pronounceable too (though less transparent, which is a trade-off you’ll need to consider).\nUse searchable names. x is a useful variable in math, not in programming. Plan ahead for when you need to cmd+f to replace all cases of a name with a slightly different version. Examples will often use p to name plots, but replacing all ps with pcgChildScatter will leave you with a lot of pcgChildScatterivot_longer()s and ungroupcgChildScatter() and pcgChildScattercg.child.compcgChildScatterares.\nPick one word/format per concept. You turned a sprawling data frame into 3 manageable intermediate data frames based on groups of related measurements. Call them gesture.freqs, gesture.rates, and gesture.ratios rather than count.gestures, summ.rates.gestures, and grats.\nAvoid encodings. This is a little more complicated (look at the source link above for more), but the gist is that names should make sense on their own and not implicitly rely on knowing what other things in the code do. The purpose of the function mean_cgfq may be decipherable if you know that the dataframe child.gesture exists and contains a frequency variable, but out of context it’s a mystery.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Solving (Your Own) Problems</span>"
    ]
  },
  {
    "objectID": "chapters/solving-problems.html#maintainable",
    "href": "chapters/solving-problems.html#maintainable",
    "title": "2  Solving (Your Own) Problems",
    "section": "4.4 Maintainable",
    "text": "4.4 Maintainable\nAim to create code that is future-proof and collaborator-proof (especially bad-collaborator-proof). It can be hard to know in the moment whether you’re writing a script you’ll never open again or one you’ll return to for years to come. Set yourself up for the latter.\n\n4.4.1 Documentation\nCreating documentation doesn’t usually need to be a major concern for beginner or intermediate programmers. However, you’ll be depending on a lot of documentation even if you’re not creating it yourself. As you start wading through the world of R packages, pay attention to the differences in documentation. Packages published to CRAN must adhere to minimum standards of documentation. Many larger packages will have their own websites or GitHub repos (in addition to CRAN) with extensive documentation, examples, and FAQs. Smaller independent and specialized packages might have extremely useful functions but leave you desperately trying to work out how to use them effectively.\nAny time you construct something usable – anything from a simple in-line function to a package to a shiny app – practice coherent documentation. Does your documentation look like the kind of documentation you find helpful? If you hand it off to a friend without any additional guidance can they figure out what to do with it?\nThink of multi-line comment chunks as a form of mini-documentation. Explain what the point of a script is at the top of a file, explain what the point of the function you’re defining is and what parameters it accepts just above the definition, etc.\n\n\n4.4.2 Lifecycles\n\n4.4.2.1 Function lifecycle\nR is constantly evolving, and R functions exist in “lifecycles.”\nIn general, you want to prioritize using functions that exist in the stable stage. A stable function is currently maintained, works with the most current version of R (and any dependent packages), and does not currently have a better option.\nNote the use of “current” in those descriptors, though. Any or all of those may change, and it’s important to keep on top of things in any code you hope to come back to in the future.\n\n\n\nLifecycle stages - sourced from lifecycle.r-lib.org\n\n\nR function lifecycle stages include:\n\nExperimental. This function is in development. Like beta software or an early access video game, this function may or may not be developed into a full, stable release. It may end up replacing currently stable functions, or it may be abandoned tomorrow. Experimental functions can be very helpful for very specific use-cases where stable functions don’t yet exist or aren’t sufficient, but you should use them with caution and add a comment noting that it’s experimental in case it breaks your code when something updates.\nStable. This function is currently operational, up-to-date, and maintained. This is the default stage, so unless the documentation indicates otherwise you can presume a function is stable. You should prioritize functions in the stable life stage.\nSuperseded. This function is still supported and isn’t going away any time soon, but it’s not going to get any further development. It is safe to use, but there is now an alternative stable function that is preferred for its use. A good example here is the gather and spread functions which have been superseded by pivot_longer and pivot_wider. Gather and spread were around for a long time and are essential to a lot of operational code, and a lot of people are used to them now and don’t really want to switch over to something new; it would be impractical to not support them. But the pivot options are just, well, better. If you have a good reason to favor a superseded function, go for it. If you’re not already familiar with it though, it’s wiser to spend your time learning the newer, stable replacement.\nDeprecated. This function works now but won’t for long. It may already not work with the current version of R, but still works with some operational older versions. Only use deprecated functions as a temporary last resort, and update with stable or experimental functions once you’re able.\n\nLearn more about lifecycles here.\n\n\n4.4.2.2 Data lifecycle\nYour data don’t exist in quite such a formal “lifecycle,” but you can thing about them in a similar way as you try to future-proof your code:\n\nHow much could your data change?\n\nIncomplete datasets will get more data (e.g., pilot datasets -&gt; final datasets)\n“Complete” datasets may eliminate some data (e.g., retroactively excluding participants or measurement timepoints)\nVariables may need to be combined, anonymized, mutated, etc.\n\nHow similar are your data to other data?\n\nFollow-up studies and replications usually need to make minor (and sometimes major) changes to data format/organization\nProblems in data collection stage that are too late to change will mean new data format when they are fixed next time\nOther researchers in your area who could benefit from your code might use similar data collection methods but different organization methods\n\n\n\n\n\n4.4.3 DRY programming\n“DRY” programming stands for “Don’t Repeat Yourself.” Generally, stop copying and pasting! There are certainly merits to copy/paste when you’re making use of external code (e.g., from stackoverflow, chatGPT suggested code, forking a repo, your own old project), but DRY coding means minimizing repetition internally, within a single script or project.\nWhen you stay DRY, you:\n\nAvoid:\n\nPropagating mistakes that must be corrected individually\nDuplication conflicts\nCombing through verbose scripts for minor errors\n\nPromote:\n\nReplicable, reproducible code\nAbstracting code for multiple contexts of use\nCode usable by and relevant to other people and future-you\n\n\n\n\n4.4.4 Abstracted coding\n“Abstracting” in the sense of DRY coding usually refers to practices like defining one function to use repeatedly rather than copying and pasting the same block of code and changing variable names every time. Abstraction exists at a finer-grained level as well, such as with paths and variables. Generally, abstracted (relative) paths and variables are more durable that hard-coded (absolute) ones.\n\n4.4.4.1 Paths\nMaximally abstracted file path references minimize broken links. As an example:\n\nNatalie's Work MacBook/Users/Natalie/repos/d2m-r/example-repo/images/barplot.jpg\n\nOnly works on Natalie’s work computer no matter what\n\n~/repos/d2m-r/example-repo/images/barplot.jpg\n\nWorks on any machine if it’s cloned to this particular location\n\n/images/barplot.jpg\n\nWorks when you clone the repo anywhere as long as the internal structure is unmodified\n\n\n\n\n4.4.4.2 Variables\nYour data will change. You want to set yourself up for making as few changes as possible to accommodate changes to your data. This is the same logic as writing your manuscript in R Markdown with in-text code and references!\n\nmy_mean &lt;- (2 + 4)/2\n\nAlways equals 3\n\nx &lt;- 2 ; y &lt;- 4\u000bor x &lt;- 3 ; y &lt;- 10\u000bthe_mean &lt;- (x + y)/2\n\nOutput will change to reflect changes to 2 input variables\n\nnumber_list &lt;- c(2,3)\u000bor number_list &lt;- 2:8\u000bor number_list &lt;- c(1,2,8,100) ; \u000ba_mean &lt;- sum(number_list)/length(number_list)\n\nOutput will change no matter how many input numerals are averaged",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Solving (Your Own) Problems</span>"
    ]
  },
  {
    "objectID": "chapters/solving-problems.html#contextualized",
    "href": "chapters/solving-problems.html#contextualized",
    "title": "2  Solving (Your Own) Problems",
    "section": "4.5 Contextualized",
    "text": "4.5 Contextualized\n\n4.5.1 Programming community “rules”\nA lot of “best practices” will apply across the board, but many will be dependent on smaller communities. R programmers don’t share exactly the same preferences for practices as C++ or Java coders. R statisticians don’t always (or ever) agree with Stats or SPSS users. Those of us working with data within academic research will have very different ideas of effective ways of organizing or presenting data “stories” than data analysts at start-ups or working in finance.\nFind your communities (plural) and do your best to respect their rules. This isn’t so much about gatekeeping and in-grouping (though it can certainty feel that way). It’s more about promoting collaboration. When everyone talks about their work in a similar way – whether it’s using the same style guide, preferring certain plots for certain analyses, opting for one package or another, formatting example random data, whatever – it’s much easier to work in forked repos, respond to crowd-sourced questions, understand others’ presentations, and just generally work together toward shared intentions.\nAlso you’ll appreciate the memes more.\n\n\n4.5.2 Project priorities\nAbove all else (or I guess below, since this is the bottom of the section, but I said this at the top, too), the best code is the code that works. You have limited time and resources. You have needs and goals specific to your project and to you as an individual. People will refer to best practices “rules,” but they are called “best practices” for a reason. They are not hard and fast rules; they aren’t supposed to be. They are what should be relatively the most useful most of the time. Get in the practice of using these guidelines when you can, but ultimately this is not what your work is about.\nKeep your project’s goals as your top priorities. Consider the context of your work and accept that it’s not going to be exactly the same as any other context, and it will be vastly different from many. Make these guidelines work for you, stay flexible, and don’t worry if and when you need to just say screw this and move on with your life.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Solving (Your Own) Problems</span>"
    ]
  },
  {
    "objectID": "chapters/solving-problems.html#other",
    "href": "chapters/solving-problems.html#other",
    "title": "2  Solving (Your Own) Problems",
    "section": "4.6 Other",
    "text": "4.6 Other\nIf you’re getting to this chapter at the beginning of the course, you can skim this part. Most won’t immediately be relevant. But when you get to the point of writing your own manuscript in R Markdown, collaborating on GitHub, or debugging code, you can return here for more specific advice.\n\n4.6.1 Notebooks, Quarto, and Markdown\n\n4.6.1.1 Editor\nDon’t use the visual editor! Quarto documentation will tell you to. I am telling you not to. You are in my class. Don’t do it.\nYou may have to delete/edit lines in your yaml header if you accidentally enable the visual editor.\n\n\n4.6.1.2 Organization\nRemember everything will run top to bottom, just like a regular .R script. Right after your YAML header, your first chunks should 1) load all libraries, 2) set document defaults (optional), 3) set a random seed (optional), and 4) source any required external scripts in a sensible order.\n\n\n4.6.1.3 Code chunks\n\nCode chunks should:\n\nDo 1 and only 1 thing. A chunk should serve a single and transparent purpose. As a rule of thumb, if you can’t describe what your chunk does in 5 or fewer words, it should probably be more than one chunk. For example, one chunk might: assemble a ggplot, render a plot or table, import or export intermediate datasets, filter data for a specific purpose, print or store the output of a regression. This means you’ll sometimes need multiple chunks for things that at first feel like one big thing.\n\nExample: Include a demographics table in your document\n\nChunk 1: Create an intermediate dataset with only relevant demographic variables and observations\nChunk 2: Perform any alternations or calculations (e.g., summarize by gender groups, create income brackets)\nChunk 3: Store a basic kable or table\nChunk 4: Render the kable in the document with the aesthetic details you want\nBy separating it into multiple chunks, you can easily refer to distinct elements. Maybe you want to create the same demo table for a different dataset. Easy! You’ll have a new Chunk 1 but 2-4 are the same. Want to call a value from the table in the text? It’s pretty messy to pull that from the “pretty” kable you rendered, but it’s simple to pull from the basic kable skeleton you built in chunk 3. Want to print a complete demo table in one place and a summarized table somewhere else? Make an alternative version of chunk 2 for the second table.\n\n\nHave informative and unique names. Name your chunks to minimize human error. In addition to helping you stay organized, this will help tremendously with troubleshooting. Error messages during the knitting process don’t always give you the precise line number, but will always give you the chunk name where the problem occurred. (This is also a good reason to keep your chunks short and for 1 purpose only.) Aim to have the chunk name clearly indicate the one “thing” your chunk does. By default, I usually use verb-noun names: read-data, summarize-demos, build-child-table, build-gesture-bar-plot. The only exception (for me) is chunks that do the actual rendering of tables or plots, which I give a simple label matched to the chunk that built it (e.g., build-gesture-stacked-bar saves a plot to the variable gestureStackedBar which is then rendered in the chunk named fig-gesture-stacked-bar).\n\nCritically, your chunk names should be:\n\nUnique (knitr will throw an error for duplicate chunk names)\nInformative (fig-gesture-stacked-bar and not bar-graph)\nConventional (conservative and correct)\n\ne.g., R variables cannot start with a numeral, so even though chunk names legally can, it’s better to avoid it\nDon’t use underscores or spaces. Even if they “work” they often won’t work. Stick to . and - as separators.\n\n\n\nSpecify whether/how they should run and print. Many chunk options are available here, but at a basic level use echo and include to tell knitr to show/hide your code and/or output and use eval to say whether to run the code at all. You can easily change these chunk settings in RStudio by clicking the gear icon in the top right corner of any chunk.\n\nShow output only: echo=FALSE\nShow code and output: echo=TRUE\nShow nothing (run the code without printing anything): include=TRUE\nShow nothing and do not run code (just ignore the whole chunk): eval=FALSE, include=FALSE\n\nBe placed at the point they are needed or referenced. In theory, you could place every single chunk at the top of the file so long as they are in the correct order relative to each other. In practice, that’s impossible to manage. The beauty of R notebooks is the seamless integration of code and narrative, making the whole thing as human-friendly as it is machine-friendly. Keep your chunks as close as possible to the point in the narrative that they are referenced to easily edit both narrative and code as you work.\nBe (relatively) short, sourcing longer scripts if necessary. Using source() will run the full code of another file. Long blocks of code or instances where the purpose of code really can’t follow the “one-chunk-one-thing” rule may call for sourcing the code as a separate script. This is especially useful for:\n\nCode that you know you will rarely or never need to make dynamic edits to, like a script that imports multiple .csv files, wrangles many sources of data, and produces multiple intermediate datasets that will be the essential data for your whole manuscript.\nScripts that you run often that aren’t project specific. For example, I have a generic startup.R script I source that loads my most commonly used libraries, sets my preferred ggplot theme tweaks, and defines color palettes.\nDedicated scripts for defining all the custom functions necessary for the project. Nearly all of my projects source a functions.R script, which all start from a basic file that has functions I use in most projects (like one that calculates SD/SE and adds error bars to plots).\n\n\n\n\n\n4.6.2 GitHub & Collaboration\n\nInclude and maintain both a .gitignore and README.md file in the top level of your repository\nMake purposeful and wise decisions about managing public, private, and protected data and files\nUse informative commit messages\nPull before you start editing; commit as you work; push when you close your session\n\n\n\n\nGit xkcd\n\n\nNever forget that the whole point of using GitHub is version control! \nDo not create a new file for each assignment. Your repo is the home of your research project, not a collection of notes and homework. Keep it organized, future-proof, collaborator-friendly, and contextualized beyond this class.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Solving (Your Own) Problems</span>"
    ]
  },
  {
    "objectID": "chapters/solving-problems.html#documentation-1",
    "href": "chapters/solving-problems.html#documentation-1",
    "title": "2  Solving (Your Own) Problems",
    "section": "5.1 Documentation",
    "text": "5.1 Documentation\n\n5.1.1 Help/lookup functions\n\n\n5.1.2 Function documentation\n\n\n5.1.3 Package documentation\n\n\n5.1.4 Resources",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Solving (Your Own) Problems</span>"
    ]
  },
  {
    "objectID": "chapters/solving-problems.html#solving-your-own-problems",
    "href": "chapters/solving-problems.html#solving-your-own-problems",
    "title": "2  Solving (Your Own) Problems",
    "section": "5.2 Solving your own problems",
    "text": "5.2 Solving your own problems\n\n5.2.1 Error messages\n\n\n5.2.2 Garbage in, garbage out (and other tropes)\n\n\n5.2.3 Line-by-line debugging\n\n\n5.2.4 Rubber ducking",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Solving (Your Own) Problems</span>"
    ]
  },
  {
    "objectID": "chapters/solving-problems.html#ask-the-internet",
    "href": "chapters/solving-problems.html#ask-the-internet",
    "title": "2  Solving (Your Own) Problems",
    "section": "5.3 Ask the internet",
    "text": "5.3 Ask the internet\n\n5.3.1 Start strong - asking good questions\n\n\n5.3.2 Crowdsource\n\n\n5.3.3 Use AI constructively",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Solving (Your Own) Problems</span>"
    ]
  },
  {
    "objectID": "chapters/solving-problems.html#ask-humans-for-classrooms-and-group-learning",
    "href": "chapters/solving-problems.html#ask-humans-for-classrooms-and-group-learning",
    "title": "2  Solving (Your Own) Problems",
    "section": "5.4 Ask humans (for classrooms and group learning)",
    "text": "5.4 Ask humans (for classrooms and group learning)\n\n5.4.1 Ask your classmates\n\n\n5.4.2 Use Slack\n\n\n5.4.3 Ask your instructor & TAs\n\n\n5.4.4 The D2M-R troubleshooting process",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Solving (Your Own) Problems</span>"
    ]
  },
  {
    "objectID": "chapters/solving-problems.html#starting-from-nothing",
    "href": "chapters/solving-problems.html#starting-from-nothing",
    "title": "2  Solving (Your Own) Problems",
    "section": "5.5 Starting from “Nothing”",
    "text": "5.5 Starting from “Nothing”",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Solving (Your Own) Problems</span>"
    ]
  },
  {
    "objectID": "chapters/solving-problems.html#exercises",
    "href": "chapters/solving-problems.html#exercises",
    "title": "2  Solving (Your Own) Problems",
    "section": "5.6 Exercise(s?)",
    "text": "5.6 Exercise(s?)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Solving (Your Own) Problems</span>"
    ]
  },
  {
    "objectID": "chapters/rstudio.html",
    "href": "chapters/rstudio.html",
    "title": "3  RStudio Essentials",
    "section": "",
    "text": "3.1 RStudio IDE",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RStudio Essentials</span>"
    ]
  },
  {
    "objectID": "chapters/rstudio.html#rstudio-ide",
    "href": "chapters/rstudio.html#rstudio-ide",
    "title": "3  RStudio Essentials",
    "section": "",
    "text": "3.1.1 Overview\n\n\n3.1.2 Integrated Development Environments (IDE)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RStudio Essentials</span>"
    ]
  },
  {
    "objectID": "chapters/rstudio.html#layout",
    "href": "chapters/rstudio.html#layout",
    "title": "3  RStudio Essentials",
    "section": "3.2 Layout",
    "text": "3.2 Layout\n\nRStudio looks like a grid of four panels which you can rearrange as you like. Your source and console panels will always be two of these four. The other two panels will be one or more tabs of useful information and actions. By default, RStudio has the following pane layout:\n\nTop left: Source\nBottom left: Console\nTop right tab group: Environment, History, Git, Build, and others\nBottom right: Files, Plots, Packages, Help, Viewer, and others\n\nYou can customize how panes are grouped in tabs and where panes and pane groups appear. See Section 3.3.5 to learn how to change pane layouts. Here is my own preferred layout, which you’ll see in screenshots throughout this book:\n\n\n\n\n\n\nFigure 3.1: Example Pane Layout\n\n\n\nThis example includes a simple R script in the source pane (top left) which has been run, producing output in the console pane (lower right) and a plot in the plots pane (top right). The objects created by the script appear in the environments pane (lower left).\n\n3.2.1 Source pane\nIn both the default layout and the example layout above (Figure 3.1), the source pane is the top left quarter of the screen. Here it is outlined in orange. This is where you will view and edit the contents of text-based files, including .R scripts and markdown documents. You can also view (but not edit) contents of existing data objects in the source pane. For example, opening a stored dataframe from the environment pane or with the View() function will open it in the source pane in an easy-to-read table format.\nAlthough you can run code directly in the console, you will most often write, edit, and run code in the source pane. The output of code run in from R scripts will appear in the console, viewer, or plot panes. The output of code in R and Quarto notebooks will appear in the document itself, below the code chunk.\nThere are a few important features of the source pane to be aware of:\n\nYou can open multiple files in the source pane, and they will appear as tabs that you can switch between.\nYou can pop out one or more files from the source pane using the “show in new window” button. This is useful if you want to view multiple files side by side. I often pop out simple text/markdown files to have as a reference, but leave any files that output to the console pane in the source pane.\nYou can run code directly from the source pane by selecting the code you want to run and pressing Cmd + Enter1, or by clicking the “Run” button in the toolbar above the source pane.\nIf you don’t select any code, using the run shortcut or run button will execute the current line of code (wherever your cursor is).\nYou can run the entire file by pressing Cmd + Shift + Enter.\n\n\n\n3.2.2 Console pane\nIn Figure 3.1, the console pane is the bottom right quarter of the screen, outlined in blue. In the default layout, it is the bottom left quarter of the screen, below the source pane. The console pane has three tabs: console, terminal, and background jobs. Note that all of these tabs together make up the console pane. The “R console” refers to the console tab within the console pane.\n\n3.2.2.1 Console tab\nWhen you run a line of code in your source script file, it will execute in the console tab. If you select a section of code and run it, you’ll see that code appear in the console, then the output will appear immediately below it.\nIf something goes wrong, or if there’s just something R thinks you should know about the code you’re running, you’ll see an error, warning, or message as well. \nYou can also run code directly in the console tab without using a source script. Just type in some R code into the console and press return to run it. You’ll see more or less the same behavior as when you run code from a source script: the code appears (or rather, it appeared as you typed it) and the output appears below.\nRun the following lines of code in the console to try it out. For multiline blocks, try both running each line one at a time and copying and pasting the entire block at once. Pay attention to both where the output appears and when it appears (or really, when it does not appear). The comments (# Which look like this) are there for you-the-human, not R. When R executes the code, it ignores everything on the line after #. You can include the comments or not, up to you.\n# Some simple math\n2 + 2\n# Assign a numeric value to a variable and then use it\nx &lt;- 5\nx * 2\n# Create a vector and calculate the mean\n# Both directly and using a variable\nmy_numbers &lt;- c(1, 2, 3, 4, 5)\nmean(c(1, 2, 3, 4, 5))\nmean(my_numbers)\n# Print a message with a string\nprint(\"Hello!\")\n# Assign a string to a variable and print it\nhello &lt;- \"Hello!\"\nprint(hello)\nRunning code directly in the R console is useful for quick calculations, testing small snippets of code, and some simple data exploration. Critically, the console does not save your code when your R session ends2, so you should not use it to run any code that you anticipate needing to run more than once or that may require editing.\nA table for quick reference of when to use a source script and when to use the console:\n\n\n\nUse Case\nSource Script\nR Console\n\n\n\n\nQuick calculations\nNo\nYes\n\n\nPlaying around with new functions\nNo\nYes\n\n\nLine-by-line debugging\nYes\nYes\n\n\nTesting small code snippets\nYes\nYes\n\n\nExploratory visualization\nYes\nYes\n\n\nExploratory data summary\nYes\nYes\n\n\nCreating objects and functions\nYes\nNo\n\n\nData wrangling & preparation\nYes\nNo\n\n\nCreating publication-ready plots\nYes\nNo\n\n\nRunning reproducible analyses\nYes\nNo\n\n\n\nThere’s really no situation where you absolutely should not run code from a script. There are simply contexts where you may prefer not to. When in doubt, just run your code from a script in the source pane.\nOne more thing to notice now is the broom icon in all three tabs. You’ll actually see this icon in most panes (other than the source pane). In Figure 3.1, one example of the broom icon is circled in the plots pane in the top right. The broom icon does basically the same thing in all panes: it clears the output of the current tab. Very handy for long coding sessions, where console output gets cluttered with messages, old broken code, and other distracting things you don’t need to see anymore.\nLearn more:\n\nRun python code directly in the R console.\n\n\n\n3.2.2.2 Terminal tab\nThe terminal tab is a command line interface (CLI) that allows you to run shell commands directly from RStudio.\n\nThis is where the operating system you’re using starts to matter. As mentioned, this book is written for a specific audience of students, and that audience overwhelmingly uses Mac. If you’re using Mac or Linux, the terminal tab will run commands in a bash shell by default. That’s what you’ll see in this book. If you’re using Windows, the terminal tab will run commands in the Windows Command Prompt (cmd) or PowerShell, depending on your settings. Thankfully, there are plenty of resources available online for using the terminal in Windows. To get you started, try this overview from Microsoft. \nThe terminal tab in RStudio functions identically to the Terminal app that runs independently. It interacts with your operating system to navigate directories, manage files, run simple text editors, and run shell commands. It does not interact with your R code.\nIn this course we will mainly use the terminal tab for git commands, so we cover the basics of bash scripts together with git commands in the Git & GitHub chapter (Chapter 5).\nWhat you need to know now: The terminal tab and console tab are two different things. You can’t run R code in the terminal; you can’t run shell commands in the console. If code isn’t working at all, check that you’re in the right tab.\n\n\n3.2.2.3 Background jobs tab\nThe background jobs tab is where you can monitor background processes that RStudio is running. Unlike the console and terminal tabs, the background jobs tab is not interactive, it is a real-time log of background processes that RStudio is running (other than code). For example, when you render a notebook with Quarto or markdown, you’ll see the processes that go into creating the document (like compiling LaTeX and markup) appear here.\nWhat you need to know now: When you render a document, errors and warnings will appear in the background jobs tab, not the console where R code errors appear. When a job is running in the background, you can click the stop sign to force quit it. There are times when RStudio will take you to the background jobs tab automatically, so like with the terminal, just be aware of which tab you’re viewing.\n\n\n\n3.2.3 Other commonly used panes\nAside from source and console, you can toggle panes on and off and group them together as tabs however you like. Note that even though we call them “panes” in RStudio, they are actually tabs within the larger pane layout, which is why you can customize the groups.\nBefore we talk details, it’s worth pointing out that many of these panes are just a GUI for R functions that you can (and usually should) run directly in the console or a source script. Can you install and load packages from the packages pane? Yes. Should you? No. You should use the install.packages() and library() functions to keep your project files and code self-contained and reproducible.\nSimilar things can be said about other panes or pane features: importing datasets in the environment pane, changing the working directory in the files pane, performing simple (and not so simple) git commands in the git pane, etc.\nIn this section, I’ll point out how to use the interactive interface for each pane, but as a student developing your R skills, you should try to learn the code equivalent for any action you take in an RStudio pane. I recommend approaching using the GUI the same way I recommend using AI. Use it as a shortcut to skip the time consuming grunt work for things you already know how to do yourself. Computers are, ultimately, pretty stupid. You need to know how this stuff actually works so you can recognize where the computer is going wrong and how to fix it.\n\n3.2.3.1 Environment pane\nIn Figure 3.1, the environment pane is the bottom left quarter of the screen, outlined in purple. Here you’ll see all the objects that are currently loaded in your R session, like dataframes, variables, and functions. In order for you to reference something in your code, you have to add it to your environment first. The environment resets when your R session restarts, so you’ll need to rerun code to recreate any objects you want to use.\nIf you have structured objects like dataframes, lists, or model output, you can click the blue arrow to expand the object and view its component parts. You can also click the name of the object to run View(objectname). This will open the object in the source pane in either a tabular format (like for dataframes) or a nested list (like for models).\nYou can remove objects from your environment with the “Clear” button (the broom icon). By default, this will clear all currently loaded objects. If you just want to remove certain objects, switch from “List” to “Grid”, select the objects you want to remove, then click the broom icon.\nThe environment pane also has a button to import datasets. It opens a relatively user-friendly window for importing data from various file formats, like CSV, Excel, and others. This is really just assisting you in writing the R code to import the data, and you can view the code that it will run as you change import options. You can play around with this to see how different import options are represented in code, but generally when you import data you’ll want to write the code yourself to include in a source script.\n\n\n3.2.3.2 History pane\nThe history pane is where you can see a list of all the commands you’ve run in your R session, whether from the console or from a source script. You can select a command from the history list and send it directly to the console or to the currently open source file.\nYou probably won’t use this pane often in your regular workflow, but it’s handy sometimes. Run something you thought was temporary in the console but now you want to keep it? Find the command and add to source. Need to rerun a quick, non-source-worthy command without scrolling up through hundreds of lines of console output? Find it in the history and run it again. Cleaned up the console two seconds before realizing you need to run that command you just ran one more time? No worries. It’s in the history.\n\n\n3.2.3.3 Files pane\nThe files pane should be familiar to you; it’s just a directory navigator like Mac’s Finder or the Windows File Explorer. It’s not quite as pretty, but it works the same way. Navigate through folders, create new files, delete and rename, etc.\nOne non-obvious thing you should know is how to view and change your working directory using the “More” menu. Think of your working directory as a you-are-here marker for RStudio. When you run code that references files (like importing data, saving plots, or sourcing scripts), you need to give R a file path to that new or existing file.\nYou could give it a full, absolute file path (like “/Users/Natalie/Documents/repos/D2M-R/data/mydata.csv”), but that’s kind of terrible. In addition to just being a pain to type, using absolute file paths is not good practice because your code becomes less portable and harder to share with others. When you try to use my code, you probably don’t have the file in a “Natalie” folder on your computer3, so it won’t work. You’ll have to manually go in and change every file path.\nBetter practice is to use relative file paths. Relative to what? Relative to your working directory. If you are working in an R project, your working directory is the root of that project. If my data file is in my D2M-R project (connected to a GitHub repo), I can just use the relative file path “data/mydata.csv” to reference it. Now when you clone my repo to your own computer, you can call it anything you want and save it anywhere you want, but as long as you keep the same relative file structure, my code will still work.\nAs long as you’re working in an RStudio project, you won’t have to manually mess with your working directory often. If you’re not in a project, or there is just some other reason you need to change your working directory, you can do so in the files pane by navigating to the desired folder and clicking the “More” button, then “Set as Working Directory”.\nAll of this is really just a GUI way of doing the same thing as the setwd() function in R or the cd command in the terminal.\n\n\n3.2.3.4 VCS (Git) pane\nIf you have a version control system (VCS) like git enabled for an RStudio project, you can enable a VCS pane. I’ll call it the Git pane, since that’s the most common VCS used with RStudio and what we’ll use in this course.\nThe git pane allows you to perform most basic git operations directly from RStudio. We’ll go over the git pane in detail in the Git & GitHub chapter (Chapter 5), but there are some basics you can get familiar with now.\nWhat you actually see displayed in the git pane is a list of files that have been changed since the last commit. This includes edits to the text, additions, deletions, and renaming. You can select modified files (or directories) to stage them, so that their changes are included in your next commit. When you’re happy with what you’ve staged, click the “commit” button. A window will pop up where you get more information about what you’re staging and let you complete the commit. In that window you can add and remove items from the staging area, view the version comparison diff, add a commit message, commit, and pull/push to a remote repository. You can also switch from “Changes” to “History” to see a list of all the commits made to the project so far.\nI list all those things out because – as you may have noticed – they are the same functions as the buttons at the top of the git pane. The buttons are a little deceptive, because they all open the same window. The push and pull buttons can perform those actions on their own, but everything else will just open up that same git interface window.\nAnother thing to mention at this point is that the git pane is great, but somewhat limited. We can do everything in a standard workflow via the git pane, but when things inevitably go wrong, you may not be able to resolve your problem in the RStudio git pane or window. In addition to being comfortable working in the git pane, you’ll need to know some basic git commands to resolve issues in the terminal.\n\n\n3.2.3.5 Packages pane\nThe packages pane is where you can manage the R packages installed on your computer. I do not recommend installing or loading packages directly from the pane, but you can. Click install to open a window where you can search for packages, select them, and install them. Click the checkbox by a package to load it into your R session. But also, well…don’t do that. Just use the install.packages() and library() functions in your source scripts.\nSome of the other things you can do in this pane are very useful, though. Aside from just having a quick reference to what packages you have installed and loaded, you can keep track of which packages are up to date and quickly update many at a time as needed.\nClick the name of the package to open the package documentation in the help pane. Click the globe4 icon to open the package’s website in your browser, if one is available.\n\n\n3.2.3.6 Help pane\nSpeaking of documentation, the help pane is where you’ll find documentation for R functions, packages, and other resources. Click the home icon to find a collection of resources about R and RStudio. You can search for documentation for a specific function or package by typing its name into the search bar. You’ll only see autocomplete selections for packages and functions that you have loaded, but you can type in anything you want and it will search for the term in CRAN documentation. (We’ll talk more about CRAN in ?sec-solving-problems).\nYou can also access help documentation by typing ?function_name or help(function_name) in the console. It will bring up the documentation for that function in the help pane, the same as if you searched for it.\n\n\n3.2.3.7 Viewer pane\nThe viewer pane is where you can rendered and interactive content like HTML files, Shiny apps, and dynamic visualizations. When you create something with Quarto in this class, it will typically open in the viewer pane by default. You can pop out the contents of the viewer pane to your default browser by clicking the “Open in Browser” button next to the broom/clear icon.\n\n\n3.2.3.8 Plots pane\nThe plots pane is (unsurprisingly) where you’ll see plots and static visualizations created in R. When you run a plotting function from an R script or the console, the output will appear here. The plots pane offers some basic functionality for interacting with plots, like zooming in, exporting the plot to a file, and clearing the plot output. As with most everything else described in this section, you can also do all of this from the console with functions like ggsave() and plot().\nNote that plots generated in R and Quarto notebooks will appear in the document itself, just below the code chunk that generates them. You can change this default behavior by selecting “Chunk Output in Console” from the gear icon in the source pane of the notebook document. As you might expect based on the wording of the option, this won’t just change where plots are displayed. It will display output of code executed in code chunks to the console instead of the document itself. This kind of defeats the purpose of working in a notebook in many ways, so I recommend sticking with the default unless you have a strong personal desire to change it.\n\n\n\n3.2.4 More panes\nThese panes won’t be used as much in this class, but you can toggle them on and off as needed:\n\nConnections pane: This pane is used to manage connections to databases and other data sources. You can connect to databases like SQLite, MySQL, and PostgreSQL, as well as other data sources like Google Sheets and AWS S3.\n\nPersonally, in my own interactions with SQL database in R I prefer to stick with writing out the code with something like the DBI package. I honestly just find the connections interface confusing.\n\nBuild pane: This pane is mostly just a button. When you’re working in certain kinds of projects, like this very Quarto book, you can click the “Build” button to render the project. This will run the build processes necessary to render to the desired output, and you’ll see the ongoing log of those processes in the background jobs pane. The rendered project will open in the viewer pane, browser, or another app like Word or Acrobat, depending on the kind of project.\n\nThe render/build button in the build pane has nearly the same functionality as the render/build button in the toolbar above the source pane. The main difference is that rendering from the source will render the currently open file, while rendering from the build pane will render the entire project.\nThe build pane won’t appear if you aren’t working in a project that has a build process defined. I find that sometimes the build pane just doesn’t appear in projects even when it is supposed to. You can always build Quarto projects directly from the terminal with quarto render, so don’t work too hard at getting the build pane to appear if it doesn’t.\n\nPresentations pane: This pane is used to view Quarto presentations, like the ones I use in class. It will only appear if you have a Quarto project open that contains a presentation file (like a .qmd file with the format: revealjs option in the YAML header).\nTutorial pane: RStudio has a built-in tutorial system called learnr. We won’t use it, but you can play around with it if you like. There’s not much else to do with the tutorial pane.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RStudio Essentials</span>"
    ]
  },
  {
    "objectID": "chapters/rstudio.html#general-settings-expected-behavior",
    "href": "chapters/rstudio.html#general-settings-expected-behavior",
    "title": "3  RStudio Essentials",
    "section": "3.3 General Settings & Expected Behavior",
    "text": "3.3 General Settings & Expected Behavior\nRStudio is extremely customizable with options and keyboard shortcuts, and you can set it up to work the way you like. You can ignore most of the settings for now, but there are a few that you should be aware of from the start. You don’t need to customize everything now, but you should know where to find the settings, what they do, and how to change them later.\nMany of my descriptions will be accompanied by a take-home “What you need to know” (WYNTK) line. Take that for what it is; you need to know it.\n\n3.3.1 Global vs. Project Options\nRStudio has both global options (which apply to all projects) and project-specific options (which apply only to the current project). You can access these settings through the “Tools” menu. When it comes to initial setup of RStudio, you’ll want to focus on the global settings first. You can then adjust project settings as needed.\nThis section will walk through the most important global options to get started in D2M-R. The screenshots are directly from my own RStudio, so you can see which options I use (though you don’t need to use the same setup!).\n\n\n3.3.2 General\n\n\n\nGeneral Options\n\n\nThe general options do, well, general stuff. You can just worry about the “Basic” tab to get started:\n\nWorking directory: Select a sensible folder to set as your default working directory. By default this will be your home directory (“~” is a stand-in for “/Users/YourName/”). In this class you’ll organize work in R projects, which have their own working directory. I recommend containing those projects (i.e., repositories) in one directory, and setting that as your working directory, e.g., “~/Documents/repos/”.\n\nWYNTK: Choose something and remember what you chose.\n\nRestore: Do you want RStudio to start fresh with no project and/or no documents open each time you open it, or do you want it to pick up where you left off?\nOther: Check the box to get notifications of RStudio updates. You want them.\n\n\n\n3.3.3 Code\n\nEditingDisplaySavingCompletionDiagnostics\n\n\n\n\n\nCode: Editing\n\n\n\nTabs or spaces: Whether to use tabs or spaces in programming is an absurd and timeless debate. R is a whitespace-insensitive programming language, meaning any kind of blank characters (both spaces and tabs) are helpful for readability but don’t matter for running the code. Use spaces, use tabs, use nothing (well, use something — human people need to read your code!). It may just be a matter of form rather than function, but you’ll likely develop a preference here. Personally I check the box and use a tab width of 4.\n\nWYNTK: Even though R is whitespace-insensitive, markdown is not. Since you’ll be working in Quarto notebooks in this course, you need to pick something and be consistent. If you end up with a mix of 2-space tabs and 4-space tabs (or anything else) markdown elements like lists will get wacky when you render.\n\nMatching parens/quotes: R uses parentheses (), single quotes ', and double quotes \" to section off elements in code and markdown. It’s critical for execution that each opening paren or quote is matched with a closing paren or quote. It’s so critical, that RStudio will just go ahead and add that closer when you add an opener. This is generally preferred behavior and I recommend using it even if it takes a bit to get used to, but you can disable it if you find it distracting.\nUse native pipe operator: By default, the Shift+Ctrl/Cmd+M keybind inserts a magrittr (tidyverse) pipe: %&gt;%. You’ll become very familiar with the pipe once we get to tidyverse programming. The newest versions of tidyverse packages support (and recommend) use of the native (base R) pipe operator: |&gt;. As of 2021’s R 4.1, the two pipes are interchangeable in tidyverse functions, but |&gt; is preferred since it will work with non-tidyverse code. Importantly, the %&gt;% pipe still works and isn’t going anywhere, so you can use it if you want. Most of my example code (and real code for my own research) uses %&gt;% as I gradually switch over.\n\nWYNTK: Both |&gt; and %&gt;% are pipe operators. With the tidyverse libraries loaded, you can use either. When you see them, know that they don’t have different meanings.\n\nOther editor preferences: Auto-intent to match multiple indentation on multiple lines, soft-wrap to see all your text, make the next line a comment if you hit enter while writing a whole-line comment…you can figure this stuff out.\nKeybindings: We’ll talk about keybindings a little later, but notice that this is where you can select a default set of keybinds and modify specifics.\nCtrl+Enter: This keybind (and Cmd-Enter on a Mac) is particularly useful. If you’re working in a source script, it will execute the “current” code where your cursor is. You can change what counts as “current.” I recommend “Multi-line R statement,” which means that R figures out the top function container your cursor is within and runs it from start to finish.\n\nWYNTK: Get used to this keybind! Whatever setting you choose, you should use this shortcut to execute code from your source. You should not be continually selecting text with your mouse and clicking the run button.\n\nSnippets: More on snippets later, but this is where you turn them on and off.\n\n\n\n\n\n\nCode: Display\n\n\nThis is visual stuff that makes it easier for your individual human brain to work in text files in RStudio. You can play around and figure out what these settings do and what you prefer. Only a couple need-to-know things here:\n\nShow line numbers: Enable this. This is critical for your own sanity and for being able to communicate anything about your code.\nShow margin: Recall that R is whitespace insensitive, so that you can hit return to start a new line anywhere you could/should insert a space. Markdown is whitespace sensitive, but it is insensitive to single line breaks in regular blocks of text (i.e., not always in all other markdown elements like headings and lists). You can have RStudio display a vertical line to give you a visual cue of a maximum character length for each line. This is completely arbitrary and for readability only, but very handy. It’s especially useful for any documents that will display literal code blocks or other elements that will run beyond normal page margins.\nEnable color previews: When you are writing colors into code (think plots), RStudio can highlight the text naming the color in the color itself. Like, “lightblue” or “#add8e6”. Very handy, especially if you want to play around with subtle(ish) hex variations.\nUse rainbow parentheses: This will make matching sets of parentheses appear in different colors as they are embedded within each other like: ( ( ( ) ) ). Most themes will do this for you automatically.\n\n\n\nMostly self-explanatory. WYNTK: There are autosave settings that you can use if you want. If you rely on autosave, don’t forget that you still need to make frequent commits!\n\n\n\n\n\nCode: Completion\n\n\nRStudio will offer autocompletion options in R scripts. This is different from Copilot suggestions, which is an AI’s best guess at writing the next bits of your code. This autocomplete is looking at the letters your typing and searching a dictionary of all available functions from base R and loaded packages. You can scroll through them with arrow keys and press tab to complete them.\n\n\n\n\n\nCode: Diagnostics\n\n\n\n3.3.4 Appearance\n\n\n\n\n\n\nFigure 3.2: General Settings\n\n\n\n\n\n\n\n\n\n3.3.5 Pane Layout\n\n\n3.3.6 Package Management\n\n\n3.3.7 R Markdown\n\n\n3.3.8 Git/SVN\n\n\n3.3.9 Copilot",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RStudio Essentials</span>"
    ]
  },
  {
    "objectID": "chapters/rstudio.html#additional-customization",
    "href": "chapters/rstudio.html#additional-customization",
    "title": "3  RStudio Essentials",
    "section": "3.4 Additional Customization",
    "text": "3.4 Additional Customization\n\n3.4.1 Keyboard shortcuts\n\n\n3.4.2 Accessibility\nRStudio offers a modest set of accessibility features like screen reading and announcements that you can adjust for your own needs. At this point the accessibility options aren’t exactly robust, but they are improving with new releases, so keep an eye on this set of options if there are features you need that are not yet available. Check out Posit’s Accessibility Guide for more up-to-date info on this front.\nRemember that you can use keyboard shortcuts and appearance options to improve accessibility even if there isn’t something directly available in the accessibility settings. RStudio also (generally) plays nicely with system accessibility features set from your Mac or PC settings.\n\n\n3.4.3 Snippets",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RStudio Essentials</span>"
    ]
  },
  {
    "objectID": "chapters/rstudio.html#file-types",
    "href": "chapters/rstudio.html#file-types",
    "title": "3  RStudio Essentials",
    "section": "3.5 File types",
    "text": "3.5 File types\nRStudio works with many file types (including any text-based files), but there are a few that you’ll use more than others. We’ll go over each in detail as they come up in the course, but here’s a quick overview of the most common file types you’ll encounter in RStudio:\n\n.R: The R script file type. This is where you’ll write and save most of your R code, at least until you become a Quarto notebook devotee.\n.md: The markdown file type. Markdown is a family of markup languages, allowing you create formatted documents using plain text syntax. Common things you’ll see styled in a markdown file are heading levels (using #, ##, ###, etc.), text styling (like *italics* and **bold**), and links ([link text](https://example.com)).\n.Rmd: The classic R notebook that combines code and markdown. Rmd = R + md. R notebooks include a YAML header to set document options (more on that later), plain text that will use pandoc to render markdown syntax into formatted text, and code chunks that will run R code and display the output in the rendered document. You can also include code directly in the markdown text to dynamically reference R objects. This will be a major part of the second half of this course!\n.qmd: The Quarto notebook file type, which function very, very similarly to R notebooks. Quarto is branded as “R Markdown 2.0” by Posit (the makers of RStudio), and it’s replacing R Markdown moving forward. If you are already a dedicated R Markdown user and don’t want to change your ways, thankfully Quarto notebooks have backwards compatibility with everything that’s always existed in R Markdown. Quarto notebooks just offer new features and enhancements.\n\nThere are some minor differences in general formatting norms and best practices, but in 99.9% of cases you should be able to take an .Rmd file, save it as a .qmd, and have no loss in functionality.\nIn D2M-R, we use Quarto notebooks instead of classic R notebooks. As of this point I’ll refer to Quarto (instead of “Quarto and R Markdown”) and Quarto notebooks or .qmds (instead of “Quarto and R Notebooks” and “.qmd and .Rmd” files) for simplicity. Know that if you are sticking with .Rmds, most things are interchangeable, but some new features and stylings will only work in .qmd files.\n\n.Rproj: The R project file type is a special file associated with each R project you create that contains meta-information about that project, like its working directory, project options, and other settings. The .Rproj file will be created automatically when you create a new project. If you try to open the .Rproj file, it will open the full project in RStudio, but you can also open it in a text editor to view and edit the contents.\n\nAll of the above are the extensions to file types, but there are also a handful of metadata files and folders you should be aware of which will (or at least can) generate automatically, though you can mostly ignore them. You should actually literally ingore them by adding them to your project repo’s .gitignore file.\nThe “.” at the beginning of these files and folders indicates that they are hidden files; they aren’t the extensions that come at the end of file names.\n\n.Rproj.user: A directory of temporary files that maintains the state of your RStudio project, like what files you have open when you exit your session.\n.Rhistory: This file stores the history of commands run in the R console for the current project. It is automatically created and updated as you run commands and used to define which previous commands you can access with up and down arrows in the terminal.\n.RData: This optional file can store objects in your environment between R sessions. You have to enable it in your options. If you’re working on a project collaboratively (or, say, a project that someone may need to clone from GitHub to grade), it’s not a great idea to use this, since it won’t be consistent.\n.Rprofile: This file can contain R code that runs automatically when you start an R session in the project. Again, not great for collaborative projects.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RStudio Essentials</span>"
    ]
  },
  {
    "objectID": "chapters/rstudio.html#guided-exercise",
    "href": "chapters/rstudio.html#guided-exercise",
    "title": "3  RStudio Essentials",
    "section": "3.6 Guided Exercise",
    "text": "3.6 Guided Exercise\n\nBasic navigation in RStudio. Create a file from the files pane and in the terminal. Check and change your working directory with the files pane, the console, and the terminal. Install and load libraries using the console and the packages pane. Do some math in the console. Look up function documentation and read it in the Help pane. Write simple code in the source pane and run it directly. Run a function from the history pane. Create a Quarto document, add some markdown text, add a code chunk. Run a code chunk in the Quarto document. Render the Quarto document.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RStudio Essentials</span>"
    ]
  },
  {
    "objectID": "chapters/rstudio.html#footnotes",
    "href": "chapters/rstudio.html#footnotes",
    "title": "3  RStudio Essentials",
    "section": "",
    "text": "As a reminder, this book presumes use of Mac OS. Documentation for shortcuts and interface actions for Windows and Linux is plentiful elsewhere, including the Posit website↩︎\nYour console input is temporarily saved in the history tab. More on that in Section 3.2.3.2.↩︎\nUnless your name is also Natalie, I suppose.↩︎\nIs that supposed what it’s supposed to be?↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>RStudio Essentials</span>"
    ]
  },
  {
    "objectID": "chapters/git-github.html",
    "href": "chapters/git-github.html",
    "title": "4  Git & GitHub",
    "section": "",
    "text": "5 Overview\nThe point of version control. What not to do.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Git & GitHub</span>"
    ]
  },
  {
    "objectID": "chapters/git-github.html#git",
    "href": "chapters/git-github.html#git",
    "title": "4  Git & GitHub",
    "section": "5.1 Git",
    "text": "5.1 Git\nIn brief, a (distributed) version control system for text-based documents, meaning: It records the history of each change that you/others submit With each submission it records a commit message, timestamp, and contributor … You are still responsible for submitting the change to the git record! Invented in 2005 by Linus Torvald as part of Linux development. It is free and open-source, and widely used by software developers (and increasingly by other professionals, including scientists) It can be installed and run locally and completely offline in a terminal or in a GUI software of your choice (e.g., these). Git is very powerful in combination with GitHub, which is a service that facilitates online storage and sharing of your documents. Still highly useful for single users.\nVersion control: History of changes Records a commit message with each change, along with timestamp and contributor Requires users to record (commit) changes, submit (push) changes, and accept (pull) changes\nOpen-source with diverse workflow uses: Widely used by software developers for 15+ years Increasingly used by professionals in both academia and industry Can run locally and offline via Terminal (command line)\nWith GitHub: Online storage, sharing, and version control with Git Designed to facilitate collaboration, but still useful for individuals\n\n5.1.1 Workflow\nexplain relationship between rstudio projects and git repos caveat that we’re talking about projects+git as a default combo, but that’s just for this class\nCardinal rules:\n\nPull when you start a new R session.\nCommit frequently as you work.\nPush when you get up from your computer for any reason.\n\nCreate a GitHub repo and corresponding R Project that are always synced\nFiles: README.md: project overview, repo structure, to-do list, etc. .gitignore: starting from the R .gitignore template yourManuscript.qmd: the home of your eventual publication references.bib: a plain-text file containing all the BibTeX entries cited in your manuscript yourCitationStyle.csl: the script used to format in-text and bibliography citations when knitting (not needed if using papaja) Folders/directories: /localonly: only present in your local R Project directory, listed in your .gitignore and so never synced to github /data: .csv/tabular data files for all raw or intermediate datasets read into in your .qmd, optional /raw subfolder for raw data read (only) into unsourced R scripts /source: .R scripts to be called in an early chunk of your .qmd, e.g., stylistic preferences, functions, minor data wrangling /images: exported figures and any image files to read-in to your R Markdown manuscript /sections: ONLY for multi-chapter publications (e.g., dissertations), where each chapter requires a separate .qmd that can run independently\n\n\n5.1.2 Git lingo\n    1. Repositories\n        1. repository / repo\n        1. initialize\n        2. clone\n        3. branch & checkout\n    2. Version control\n        1. commit\n        3. stage\n        4. fetch\n        6. pull\n        7. push\n    3. Merging\n        1. diff\n        2. merge\n        3. merge conflict\n        4. rebase\n        5. fast-forward (ff)\n        6. squash\n        7. cherry-pick\n        8. stash\n    4. Remote repositories\n        1. remote\n        2. origin\n        3. upstream\n        4. fork\n        5. pull request\n    5. (Optional) Using Git in the terminal",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Git & GitHub</span>"
    ]
  },
  {
    "objectID": "chapters/git-github.html#repo-structure",
    "href": "chapters/git-github.html#repo-structure",
    "title": "4  Git & GitHub",
    "section": "5.2 Repo structure",
    "text": "5.2 Repo structure\n\n5.2.1 What does and does not go in a repo?\nYour R Project is essentially a mirror of your GitHub repo It may also contain some files that don’t get uploaded to GitHub Stored on your local hard drive DO NOT use any location that syncs to cloud storage! Your project and repo both include: a README.md file with basic repo documentation a .gitignore file that specifies what shouldn’t get synced .R (R script) files .qmd (R Markdown) files .csv files or other minimal, tabular data\n\n\n5.2.2 Top-level essentials\n    1. README \nSimple markdown document (.md) What you see rendered on a repo’s GitHub page Describes the repo’s purpose and function\nSimple markdown document (.md) What you see rendered on a repo’s GitHub page Can do lots of things, but should at a minimum describe: Purpose of the repo Dataset(s) Repo structure\n\n    2. .gitignore\nPlain text file w/out extension List of files & folders that should be excluded from all git processes Allows you to protect sensitive data\nWhat is it? A text document that lets you keep some things just on your computer, not uploaded to GitHub. Why does it start with a period? It’s marking that it’s a hidden file. For the most part, you never need to interact with hidden files (hence the hiding), but .gitignore is an important exception.\nPlain text file w/out extension Files & folders that should be excluded from all git processes Matched on strings in file/folder names, including wildcard characters and simplified regex View documentation\n\nNot everything can or should be online. Private, sensitive, and protected data should be stored locally. Files generated by your scripts are redundant. Very large files can exceed upload limits and/or cause RStudio to hang. Upload directly through GitHub or use GitHub Desktop for pushes that RStudio can’t handle.\nPrivate, sensitive, and protected data should be stored locally and only pushed when you are confident it is in an ethically shareable state\nOptionally start from a template Use informative #comments Media files (e.g., .wav, .mpg) tend to be very large, often sensitive data Compiled files (e.g., .doc, .pdf, .png) really big, regenerated when you run your code A dedicated “localonly” folder for stuff you want to ignore that the .gitignore might not otherwise catch – all your sensitive data should be in here Meta-process files “knitting” creates temporary files as it turns your .Rmd into a pdf document that serve no purpose once the knitting has completed e.g., .log, .zip “Pretty” files & specialized files powerpoints, photos no one needs your .bdl*, .ear**, and .mgh files\n\n\n5.2.3 The rest of your stuff\n\n\n5.2.4 Metadata and information\n\n\n5.2.5 Example: My go-to repo structure\nFiles: README.md: project overview, repo structure, to-do list, etc. .gitignore: starting from the R .gitignore template yourManuscript.Rmd: the home of your eventual publication references.bib: a plain-text file containing all the BibTeX entries cited in your manuscript yourCitationStyle.csl: the script used to format in-text and bibliography citations when knitting (not needed if using papaja) Folders/directories: /localonly: only present in your local R Project directory, listed in your .gitignore and so never synced to github /data: .csv/tabular data files for all raw or intermediate datasets read into in your .Rmd, optional /raw subfolder for raw data read (only) into unsourced R scripts /source: .R scripts to be called in an early chunk of your .qmd, e.g., stylistic preferences, functions, minor data wrangling /images: exported figures and any image files to read-in to your R Markdown manuscript /sections: ONLY for multi-chapter publications (e.g., dissertations), where each chapter requires a separate .Rmd that can run independently",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Git & GitHub</span>"
    ]
  },
  {
    "objectID": "chapters/git-github.html#github",
    "href": "chapters/git-github.html#github",
    "title": "4  Git & GitHub",
    "section": "5.3 GitHub",
    "text": "5.3 GitHub\n\n5.3.1 What is GitHub? How is it different from Git?\n\n\n5.3.2 GitHub features\n\n5.3.2.1 Issues\n\n\n5.3.2.2 Pull requests\n\n\n5.3.2.3 Pages\n\n\n5.3.2.4 Copilot\n\n\n5.3.2.5 More\nWe won’t use these in this class, but they’re worth knowing about.\n\nActions\nProjects\nCodespaces\nWikis\nOrganizations\n\n\n\n\n5.3.3 Interfacing with GitHub (without RStudio)\n\n5.3.3.1 GitHub website\n\n\n5.3.3.2 GitHub Desktop\n\n\n5.3.3.3 Other options\nIf you’re already comfortable with other tools, you can use them to interface with GitHub. We won’t use them in this class. Some popular options include:\n\nVS Code and other IDEs\nGitHub CLI\n\n\n\n\n5.3.4 Interfacing with GitHub in RStudio\n\n5.3.4.1 Connecting RStudio to GitHub\n\n\n5.3.4.2 Using GitHub in RStudio\nThe most common git tasks with RStudio:\n\nCloning a repo\nCommitting changes\nPushing changes\nPulling changes\nResolving merge conflicts\nCreating pull requests",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Git & GitHub</span>"
    ]
  },
  {
    "objectID": "chapters/git-github.html#git-pains",
    "href": "chapters/git-github.html#git-pains",
    "title": "4  Git & GitHub",
    "section": "5.4 Git Pains",
    "text": "5.4 Git Pains\n\n5.4.1 Common issues\n\n\n5.4.2 Helpful resources\n\n\n5.4.3 The nuclear option",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Git & GitHub</span>"
    ]
  },
  {
    "objectID": "chapters/r-language-basics.html",
    "href": "chapters/r-language-basics.html",
    "title": "5  R Language Basics",
    "section": "",
    "text": "5.1 Overview\nR is a programming language and software environment based on another programming language called S. It is primarily used for data management, analysis, and presentation. R is free to use and open-source, making it both approachable to new learners and flexible for advanced users. R is built on collaboration and transparency, with a large community contributing to the development of the language and tools extending its functionality. The R community also works to make R accessible and functional, with extensive documentation for the language itself and its packages of functions. Beyond documentation, you can find a wealth of user-created resources for learning and using R, including freely available tutorials, videos, workshops, and full courses and textbooks (ahem).\nThis chapter will introduce you to some of the most critical concepts for programming with R and give you enough basic knowledge to get started writing and running R code without getting bogged down in the weeds of technical details. Some of what you’ll find here is intentionally a bit shortcut-y. We’ll go into more depth on many of these topics in later chapters.\nFair warning: It’s hard to explain data types without referencing data structures, data structures without referencing functions, operators without referencing operators, operators without referencing data types…Just bear with it. Take in what you can on your first pass knowing it’s unlikely to make perfect sense immediately.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>R Language Basics</span>"
    ]
  },
  {
    "objectID": "chapters/r-language-basics.html#overview",
    "href": "chapters/r-language-basics.html#overview",
    "title": "5  R Language Basics",
    "section": "",
    "text": "R vs. Python\n\n\n\nBoth R and Python are popular choices for statistical analysis and visualization in research, and the two have a lot in common. They are both free, open-source languages with large communities and extensive libraries of functions. The biggest difference between the two is that R is primarily focused on statistical analysis and visualization, while Python is a general-purpose programming language that can be used for data analysis as well as a range of other applications. Because R is highly specialized, a little code and knowledge go a long way. Although Python is more widely used generally, R tends to be favored in academic and research settings, especially in the social sciences. There’s really no reason not to just learn both, but this class is about R and you’re the one who chose to take it, so that’s what we’re doing.\n\n\n\n5.1.0.1 RStudio\nWe talked about RStudio in ?sec-rstudio, but in case you missed it, here’s some things to know as you get started with R.\nR is a programming language; RStudio is an integrated development environment (IDE) for that language. You interact with R via the RStudio software. R exists without RStudio, but not the other way around.\nWell, at least in theory. In practice, RStudio is the way to interact with R. It’s a (relatively) user-friendly interface for writing and executing R code that is pretty streamlined to the needs of the R user. Unlike other popular IDEs (e.g., Visual Studio, AWS, Eclipse), RStudio doesn’t need to meet the needs of any programmer who might be doing anything in any language. Consequently, RStudio is the go-to for R users, since it lacks the clutter that comes with general-purpose IDEs.\nWYNTKN:\n\nR =/= RStudio…\n…but it kinda might as well.\n\n\n\n5.1.0.2 Object-oriented programming\nR is an object-oriented programming language, which means that it is built around the concept of “objects” that contain data and functions. What’s an object? According to Wikipedia, an object is “an entity that has state, behavior, and identity.” I personally find that definition to be baffling, because like…isn’t that anything?\nWell, it kind of is anything. You can think of objects in R as any thing you want to work with in R. If it’s something you’d want to put a label on for some reason, that’s an object. A number or string as a variable to use later? Object. A table with data? Object. The output of a statistical test? Object. A plot? Object.\nYou get the idea. Basically, every time you open up a new R session, you are the god of a tiny little empty world. If you want to see something happen in your world, you have to create the stuff that does the happening and is happened to and is the happening.1 Want to watch the denizens of your universe put on a play about a magician who eats too much cheese? You have to bring into existence the players, the script, and the stage, but also the concepts of “play,” “magician,” “cheese,” “eating”, and “the amount that is socially and/or biologically too much cheese.”\nIn R, if you want to see a graph of the relationship between how much cheese an individual eats and whether or not they are a magician, you have to create that world with objects – the environment. The variables “how much cheese” and “is magician?” are objects. The rows, columns, and values that make up a table of data are objects. Those objects are all inside of an object that is the table itself. The calculation of the association between the two variables is an object. The graph that visualizes the relationship is an object. The axis labels on the plot object are objects…\nWYNTKN:\n\nR works by doing stuff to stuff.\nSo “stuff” has to exist.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>R Language Basics</span>"
    ]
  },
  {
    "objectID": "chapters/r-language-basics.html#r-syntax",
    "href": "chapters/r-language-basics.html#r-syntax",
    "title": "5  R Language Basics",
    "section": "5.2 R syntax",
    "text": "5.2 R syntax\n\n\n\n\n\nIn natural language, syntax is the system of rules that govern how words are combined to form phrases and sentences in meaningful ways. Sentence makes mixing nothing all words of at the a it something up else or mean.2\nSome things are nouns, some are verbs. Some verbs need objects, some don’t. Some words mean more than one thing and require specification or context. Some words connect other words together. Some words don’t serve a lot of functional purpose but make the sentence sound better or easier to understand. Words like pronouns can replace other words, but only after following the rules to let you do that. Some words you can omit entirely by restructuring other parts of the sentence. Some rules will technically communicate a meaning correctly, but are much more understandable if there is non-speech stuff like gestures or facial expressions to help clarify the meaning. Some rules are more flexible than others, and some are more rigid. Some rules are more important than others, and some are more about style than substance.\nIn a programming language, syntax works similarly. R syntax is the set of rules that govern how you write code in R to make it do what you want it to do. For each example I gave for natural language above, I can think of at least one equivalent situation. Adding in stuff that isn’t necessary to make it easier to read? That’s taking advantage of R being whitespace insensitive. Using gesture to complement ambiguous meaning? That’s using comments. Eliding a subject because it’s implicit or otherwise already understood? That’s skipping optional arguments in functions, or using the pipe operator to pass objects from arguments in one function to arguments in another. You get the picture.\nWhile programming languages are nowhere near as complex and dynamic as natural languages, you can think about programming syntax as using the same kinds of building blocks.\n\n5.2.1 Environments\nYour R environment is the collection of objects that exist in your R session at any given time. When you start a new R session, your environment is empty. Creating variables, data structures, functions, plots, and other objects adds them to your environment so you can refer to them later.\nEverything in your environment has a unique identifier, the name you give the object. Because identifiers are unique, creating an object with the same name as an existing object will overwrite the existing object with the new one.\nYou can see the objects in your environment by looking at the Environment pane in RStudio, or by using the ls() function in the R console to list the objects in your environment. Critically, you can only interact with objects that exist in your environment, and environments are not persistent across R sessions. When you close RStudio, your environment is cleared, and you have to recreate any objects you want to use in the next session.\n\n\n5.2.2 Variables\nVariables are the nouns of R syntax. The real world is filled with “things,” literal and abstract. Coffee, computer, RStudio, exhaustion, education, Stardew Valley Junimo plushie, the joy of playing Stardew Valley when you should be working… They just kind of exist. I can interact with them directly, but I can’t list out for you the Stardew Valley decor in my office3 unless I name them. The Junimo is a value, and “Junimo” is the variable name I use to refer to that value.\n\nIn R we create variables by assigning a value to a name with the assignment operator &lt;-. Technically you can use = to assign a value to a variable, but you really shouldn’t; &lt;- is the preferred assignment operator in R.\nOnce you have created a variable, you can use it in your code to refer to the value it contains, including assigning other variables.\n\nFor example:\n\nthe_answer &lt;- 42\npi &lt;- 3.14159\nround_answer &lt;- pi*the_answer\n\nmy_name &lt;- \"Natalie\"\nyour_name &lt;- \"Lucas\"\nour_names &lt;- c(my_name, your_name)\nYou can even assign values to variables using the existing variable itself:\nbest_game &lt;- \"Stardew\"\nsecond_word &lt;- \"Valley\"\nbest_game &lt;- paste(best_game, second_word)\n\n\n5.2.3 Functions\nIf variables are nouns, functions are the verbs of R syntax. Functions take stuff and do stuff to it.\nYou can recognize a function in R as a word(ish thing) followed by (): mean(), filter(), ggplot().\nA function is an action itself – working, eating, procrastinating, voting – which exists conceptually on its own just fine. Calculating a mean, filtering to a subset of data, mapping data to a plot – all sensible and understandable on their own, but not necessarily implementable as is.\nTo employ a function and tell R to do the thing, you will (usually) put one or details inside the parentheses: mean(x), filter(data, condition), ggplot(data = df, aes(x = var1, y = var2)). These are called arguments, and can be values, variables, or even other functions.\nWhen you pass an argument to a function (i.e., you include it in the parentheses), the function does the action to the argument(s) and returns the result.\nWe’ll talk more about arguments in Section 7.3. Here’s WYNTKN:\n\nFunctions take 0 or more arguments.\nArguments can be required or optional.\nView all possible arguments in a function’s documentation with ?functionname or ??functionname.\nIf you pass arguments to a function in the order they are defined in the documentation, you can omit the argument names. Otherwise you start with theargumentname =.\n\nround(3.14159) is the same as round(x = 3.14159), but round(2. 3.14159) is not the same as round(digits = 2, x = 3.14159).\n\n\n# Load the tidyverse packages to use filter, mutate, str_length, and ggplot\nlibrary(tidyverse)\n\n# String\n\n# Create a numeric vector of favorite numbers and calculate the mean\nfavorite_numbers &lt;- c(11, 37, 42, 101, 202, 1000, 2025, -3)\nnumber_words &lt;- c(\"eleven\", \"thirty-seven\", \"forty-two\", \"one hundred one\", \n                  \"two hundred two\", \"one thousand\", \"two thousand twenty-five\", \"negative three\")\n\n# Do some simple functions with the vectors\nmean(favorite_numbers)  # returns 426.875\nlength(number_words)  # returns 8\n\n# Create a data frame with two columns: number and word\nnumbers_df &lt;- data.frame(\n  number = favorite_numbers,\n  word = number_words\n)\n\n# View the first 6 rows of the data frame\nhead(numbers_df)\n\n# View the first 3 rows by adding an optional argument\nhead(numbers_df, n = 3)  # returns first 3 rows\n\n# Return rows where number is greater than 100\nfilter(numbers_df, number &gt; 100)  \n\n# Add a new column 'length' with the number of characters in 'word'\nnumbers_df &lt;- numbers_df |&gt; \n    mutate(length = str_length(word)) \n    \n# Plot the relationship between the number and the length of its word representation\nggplot(numbers_df, aes(x = number, y = length)) +\n    geom_point() +\n    geom_smooth(method = \"lm\")\nAt this point it’s not important that you understand everything going on in the code above. Just look at how functions are represented, what arguments can look like, how some arguments are optional, and what the function returns (or doesn’t return) as output.\n\n5.2.3.1 Functions to get started\nNow is a good time to play around with R functions to get a feel for how they work. The functions below are a collection of some of the base R functions you’re likely to use often. Try running the examples in your R console to see what they do, then try changing the inputs to see how the output changes.\nYou can also use the ?functionname command to view the documentation for any function, which will describe what the function does, its arguments, and its return value.\n\n5.2.3.1.1 Generally useful base R functions\n\n\n\n\n\n\n\n\n\nFunction\nDescription\nExample\nOutput\n\n\n\n\nc()\nCombine values into a vector\nc(1, 2, 3)\nc(1, 2, 3)\n\n\npaste()\nConcatenate strings together\npaste(\"Hello\", \"world!\")\n\n\n\ndata.frame()\nCreate a data frame from vectors\ndata.frame(x = 1:3, y = c(\"a\", \"b\", \"c\"))\nA data frame with 3 rows and 2 columns named x and y\n\n\nclass()\nCheck the data type of an object\nclass(3.14)\n\"numeric\"\n\n\nstr()\nDisplay the structure of an object\nstr(mtcars)\nA summary of the mtcars data frame\n\n\nlength()\nGet the length of a vector\nlength(c(1, 2, 3, 4, 5))\n5\n\n\nhead()\nView the first few rows of a data frame or vector\nhead(mtcars)\nThe first 6 (default) rows of the mtcars data frame\n\n\nsummary()\nGet a summary of a data frame or vector\nsummary(mtcars)\nSummary statistics for each column in the mtcars data frame\n\n\n\n\n\n5.2.3.1.2 Math & statistics\nFor the examples below, start with defining a vector of numeric values:\nnumber_list &lt;- c(11, 37, 42, 101, 202, 1000, 2025, -3)\n\n\n\n\n\n\n\n\n\nFunction\nDescription\nExample\nOutput\n\n\n\n\nround()\nRound a numeric value to a specified number of decimal places\nround(67.1988, 2)\n67.2\n\n\nsum()\nCalculate the sum of a numeric vector\nsum(number_list)\n3415\n\n\nmin()\nFind the minimum value in a numeric vector\nmin(number_list)\n-3\n\n\nmax()\nFind the maximum value in a numeric vector\nmax(number_list)\n2025\n\n\nmean()\nCalculate the mean of a numeric vector\nmean(number_list)\n426.875\n\n\nmedian()\nCalculate the median of a numeric vector\nmedian(number_list)\n71.5\n\n\nsd()\nCalculate the standard deviation of a numeric vector\nsd(number_list)\n726.7456693\n\n\ncor()\nCalculate the correlation between two numeric vectors\ncor(number_list[1:4], number_list[5:8])\n-0.2855236\n\n\n\n\n\n\n\n5.2.4 Data types\n\n\n\n\n\n\n\nComplex and raw data\n\n\n\nFor our purposes, we don’t need to worry about complex and raw data types. Complex objects use complex (i.e. both real and imaginary \\(i\\)); raw objects are used to represent literal binary data. It’s unlikely that as a researcher in psychology or other social sciences you will need to use these data types directly, but you can start to learn more about complex numbers in R here and raw data here if you’re interested.\n\n\nData you can work with in R takes one of 6 forms: numeric, integer, complex, character, logical, and raw.\nAside from these 6 “base” data types, we commonly talk about a few other kinds of things using the same kind of language we use to talk about data types, including factors, dates, and date-times/POSIX.\n\nHere’s a table summarizing the 4 R base data types we use frequently and the 3 honorary ones:\n\n\n\n\n\n\n\n\nData type\nDescription\nExample\n\n\n\n\nNumeric\nDecimal numbers, including whole numbers\n3.14, 42.0, -1.5\n\n\nInteger\nWhole numbers, represented with an L suffix\n42L, -1L, 1000L\n\n\nLogical\nBoolean values, either TRUE or FALSE\nTRUE, FALSE, x &gt; 5\n\n\nCharacter\nText strings, enclosed in quotes\n\"hello\", '123', \"R is great!\"\n\n\nFactor\nLeveled categorical data, stored as integers with labels\nfactor(c(\"low\", \"medium\", \"high\"))\n\n\nDate\nDates, stored as a special class of object\nas.Date(\"2025-01-31\")\n\n\nPOSIXct\nDate-time objects, which include both date and time\nas.POSIXct(\"1776-07-04 12:01:59\")\n\n\n\nYou can check the data type of an object using the class() function, which will return the class of the object. Try using class() on the examples above to see what it returns, like:\nclass(3.14)          # \"numeric\"\nclass(42L)           # \"integer\"\nclass(TRUE)          # \"logical\"\nclass(\"hello\")       # \"character\"\nclass(factor(c(\"low\", \"medium\", \"high\")))  # \"factor\"\nclass(as.Date(\"2025-01-31\"))  # \"Date\"\nclass(as.POSIXct(\"1776-07-04 12:01:59\"))  # \"POSIXct\" \"POSIXt\"\nNotice that for our 3 honorary data types we didn’t just pass it a value, we passed it a function that turned a value into the type we wanted.\nWhen you run class() and it returns something, it’s creating a data object which has to have a type itself. See if you can figure out what kind of data is being returned with class() by using class()4\n\n5.2.4.1 Numeric\nNumeric variables are, unsurprisingly, numbers. Basically any number that you can treat like a number. If you added 0 to it, would it equal itself? If so, it’s numeric. (As opposed to a string that looks like a number, like \"100\". Can’t add 0 to that. If you had to find a way to force it, it would probably be something like concatenation: \"1000\".)\nCreate a numeric variable by assigning a number made up of digits, decimals, and/or negative signs to a variable name:\nmy_number &lt;- 3.14\nmy_other_number &lt;- -42\n\n\n5.2.4.2 Integer\nThe integer variable is a subset of numeric variables. A number that does not have a decimal point is an integer. Integers are whole numbers (1, 5, 100000), negative whole numbers (-1, -5, -100000), and zero (0).\nPick your favorite number without a decimal point, and assign it to a variable name, then run class() on that variable to see its data type:\nlucky &lt;- 11\nclass(lucky)  # ???integer???\nRunning class on something that looks like an integer will return numeric, not integer. Remember that integers are a subset of numeric variables, so R is taking a better-safe-than-sorry approach and assuming you want the more generic, broad-scope version of what you gave it.\nIf you want to specify a variable as an integer, you can do so by adding an L suffix to the number when you assign it to a variable:\nluckier &lt;- 11L\nclass(luckier)  # \"integer\"!\nYou can also convert an existing numeric value to an integer with as.integer():\nmy_number &lt;- 42\nclass(my_number)  # \"numeric\"\nmy_integer &lt;- as.integer(my_number)\nclass(my_integer)  # \"integer\"\nYou can use as.integer() on non-integer numeric values. The result will be everything before the decimal point, effectively rounding down to the nearest whole number:\nmy_decimal &lt;- 4.2 # numeric type\nanother_integer &lt;- as.integer(my_decimal) # 4 - integer type\nSpecifying data as integer with L or converting it with as.integer() typically isn’t necessary, but it can be useful when you need to ensure that a value is treated as an integer, like as an argument of a function that only accepts integers.\nThe flip of the integer is a double variable, which is the default numeric type in R. It just means the number can have a decimal point, whether or not it’s visually represented. Since numeric values are double by default, you won’t see class() return “double”, you just mentally note that that’s what you’ve got.\n\n\n5.2.4.3 Character\nCharacter variables are “strings” of text, which can include letters, numbers, punctuation, and other symbols. You’ll hear a few different terms that all functionally mean the same thing, including “character”, “string”, “character vector”, and “text”.\nA character is the smallest element that can be represented in text. Individual letters like “d” or “R”, digits like “2”, and symbols like “-”. R is case sensitive, so “d” and “D” are different characters.\nThink of a string as the actual sequence of characters strung together. d2m-R is a string of 5 characters: d, 2, m, -, and R.\nA character vector is a collection of one or multiple strings. The string d2m-R is a list of 1 sequence of (5) characters.\nThis gets confusing, but in practice this doesn’t matter much. Text is a more general term without a specific technical definition in R, often used to talk about strings and character data.\nYou’ll often hear “text,” “string,” and “character” used interchangeably. You just need to know that “character” is the technical term for the data type in R and “string” is the sequence of text that your human brain is processing as a single meaningful unit.\nWe create a character variable by assigning a string of text to a variable name, using either single or double quotes to enclose the text:\nwith_single_quotes &lt;- 'This string uses single quotes.'\nwith_double_quotes &lt;- \"This string uses double quotes.\"\nWhy the option to use either single or double quotes? Try running these two lines of code:\nno_single_quotes &lt;- \"This string doesn't use single quotes.\"\nno_double_quotes &lt;- 'This string doesn't use double quotes.'\nThe second line will throw an “unexpected symbol” error. R saw you start a string with ', looked for another ' to end the string, and treated everything between them as the string. When it got to the “t” in “doesn’t”, R no longer thought you were trying to define a string, and it didn’t know what do with the input t use double quotes.'\nGenerally I recommend using double quotes for strings, since it avoids the need to escape single quotes in contractions and possessives. Use single quotes in the rare cases you need to include double quotes in a string.\nIn ?sec-stringr, we’ll cover how to include single quotes in single quoted strings (and double in double) if needed by escaping the quote character with a \\. In that chapter we’ll talk a lot more about working with strings in R, including how to manipulate and analyze text data using the tidyverse stringr package, your go-to for working with strings in R.\n\n\n5.2.4.4 Logical\nLogical variables are Boolean values, meaning they can only take on one of two possible values: TRUE or FALSE.\nIn R, logical values are written in all caps, either the whole word or the first letter:\nis_true &lt;- TRUE\nis_false &lt;- FALSE\nalso_true &lt;- T\nalso_false &lt;- F\nnot_logical &lt;- true  # Error: object 't' not found\nalso_not_logical &lt;- f  # Error: object 'f' not found\nLogical variables are usually the result of comparison operations, which evaluate to either TRUE or FALSE:\nis_greater &lt;- 5 &gt; 3  # TRUE\nis_equal &lt;- 5 == 5   # TRUE\nis_less &lt;- 3 &lt; 1     # FALSE\nis_not_equal &lt;- 5 != 5  # FALSE\nMore on logical comparisons in Section 5.2.5.2.\nIn practice, you’ll usually use logical variables in the context of conditional statements and loops. More on those in Section 7.4.\nYou may also encounter logical variables directly in your data (e.g., survey data where respondents answer yes/no questions) or need to wrangle categorical data into logical variables.\n\n\n5.2.4.5 Factor\nFactors variables represent discrete groups or levels. This is the word R uses for what you may prefer to call categorical, nominal, ordinal, or discrete variables (among others).\nFactor variables may not be immediately distinguishable from character variables when you look over your data, but they function very differently.\nA character variable is a string of text, and all strings are treated as unique values – even if they are identical. While R can compare two strings and determine whether they are identical:\nis_same &lt;- \"happy family\" == \"happy family\"  # TRUE\nis_different &lt;- \"unhappy family\" == \"Unhappy Family\"  # FALSE\nit can’t know whether strings are meaningfully identical.\nConverting a character variable – or any variable with discrete values – to a factor variable tells R that the values represent meaningful groups or levels. Each unique string it detects is treated as a level of the factor variable.\nYou’ve got a survey about college students’ names, their breed of pet, and overall happiness on a 4-point scale (1 = horribly depressed, 2 = mostly numb, 3 = pretty ok, 4 = weirdly great):\n\nsurvey_data &lt;- data.frame(\n  name = c( \"David\", \"Eve\", \"Jamal\", \"Alice\", \"Fatima\", \"Grace\", \"Alice\", \"Heidi\", \"Bob\", \"Carlos\", \"Ivan\", \"Grace\"),\n  pet_breed = c(\"dog\", \"none\", \"dog\", \"bird\", \"cat\", \"dog\", \"cat\", \"none\", \"fish\", \"cat\", \"none\", \"ignuana\"),\n  happiness = c(3, 4, 2, 1, 3, 4, 2, 3, 1, 4, 1, 4)\n)\n\nsurvey_data\n\n     name pet_breed happiness\n1   David       dog         3\n2     Eve      none         4\n3   Jamal       dog         2\n4   Alice      bird         1\n5  Fatima       cat         3\n6   Grace       dog         4\n7   Alice       cat         2\n8   Heidi      none         3\n9     Bob      fish         1\n10 Carlos       cat         4\n11   Ivan      none         1\n12  Grace   ignuana         4\n\n\nIf you run class() on each of the columns, you’ll see that name and pet_breed are character variables, while happiness is numeric:\nclass(survey_data$name)        # \"character\"\nclass(survey_data$pet_breed)   # \"character\"\nclass(survey_data$happiness)    # \"numeric\"\nIt makes sense that name is a character variable, since names are unique strings of text. Even if a couple are repeated, that’s just coincidence. We don’t care about an effect of “name.”\nThe pet_breed character variable would be more appropriately handled as a factor variable, since the values represent discrete groups. David, Jamal, and Grace all have dogs – we need to be able to treat all cases of dog the same way to do anything with that information.\nThe way it’s being handled right now just isn’t helpful, which you can see easily by summarizing the data:\n\nsummary(survey_data)\n\n     name            pet_breed           happiness    \n Length:12          Length:12          Min.   :1.000  \n Class :character   Class :character   1st Qu.:1.750  \n Mode  :character   Mode  :character   Median :3.000  \n                                       Mean   :2.667  \n                                       3rd Qu.:4.000  \n                                       Max.   :4.000  \n\n\nWe can’t learn anything about patterns with pet breed here. It needs to be a factor variable.\nThere are two big base functions you need working with factors; You can convert a character variable to a factor variable with factor() and look at the levels of the factor with levels():\nNow summarizing the data immediately gives us some quick, useful information about the distribution of pet breeds in our sample:\n\nsummary(factored_data)\n\n     name             pet_breed   happiness    \n Length:12          bird   :1   Min.   :1.000  \n Class :character   cat    :3   1st Qu.:1.750  \n Mode  :character   dog    :3   Median :3.000  \n                    fish   :1   Mean   :2.667  \n                    ignuana:1   3rd Qu.:4.000  \n                    none   :3   Max.   :4.000  \n\n\nPet breed is an unordered factor. There is no objective way to rank them. You can’t mathematically say that a dog is “more” or “less” than a cat, however passionately you may feel one way or the other.\nThe happiness variable is numeric, representing a 4-point scale of overall happiness. If this was truly a numeric, continuous variable, what would it mean to have a happiness level of 2.334? Somewhere between mostly numb and pretty ok, but with no meaningful precision.\nThis is actually an ordered factor (or ordinal variable), meaning that the values represent a meaningful order or ranking, but the intervals between the values are not necessarily equal or divisible. We can convert this numeric-looking variable to a factor the same way we did with the string-looking variable, using factor(), but we need to add an argument to specify that the levels are ordered:\n\n# convert happiness to an ordered factor variable\nfactored_data$happiness &lt;- factor(factored_data$happiness, \n                                 levels = c(1, 2, 3, 4), # r can usually figure this out on its own, but it doesn't hurt\n                                 ordered = TRUE)\n                                 \n# check the class and levels of the new ordered factor variable\nclass(factored_data$happiness)  # \"ordered\" \"factor\"\n\n[1] \"ordered\" \"factor\" \n\nlevels(factored_data$happiness)  # \"1\" \"2\" \"3\" \"4\"\n\n[1] \"1\" \"2\" \"3\" \"4\"\n\n\nAt this point, you could decide that it’s more useful to have the levels labeled with their meanings instead of numbers. Good old factor() can do that too, with the labels argument:\n\n# convert happiness to an ordered factor variable with labels\nfactored_data$happiness_label &lt;- factor(factored_data$happiness, \n                                 levels = c(1, 2, 3, 4), \n                                 labels = c(\"horribly depressed\", \"mostly numb\", \"pretty ok\", \"weirdly great\"),\n                                 ordered = TRUE)\n                                 \n# check the class and levels of the new ordered factor variable with labels\nclass(factored_data$happiness_label)  # \"ordered\" \"factor\"\n\n[1] \"ordered\" \"factor\" \n\nlevels(factored_data$happiness_label)  # \"horribly depressed\" \"mostly numb\" \"pretty ok\" \"weirdly great\"\n\n[1] \"horribly depressed\" \"mostly numb\"        \"pretty ok\"         \n[4] \"weirdly great\"     \n\n\nLooking at the structure of the data frame can give some clarity on what R is doing with the factor variables:\n\nstr(factored_data)\n\n'data.frame':   12 obs. of  4 variables:\n $ name           : chr  \"David\" \"Eve\" \"Jamal\" \"Alice\" ...\n $ pet_breed      : Factor w/ 6 levels \"bird\",\"cat\",\"dog\",..: 3 6 3 1 2 3 2 6 4 2 ...\n $ happiness      : Ord.factor w/ 4 levels \"1\"&lt;\"2\"&lt;\"3\"&lt;\"4\": 3 4 2 1 3 4 2 3 1 4 ...\n $ happiness_label: Ord.factor w/ 4 levels \"horribly depressed\"&lt;..: 3 4 2 1 3 4 2 3 1 4 ...\n\n\nNow we can see that name is a character vector with at least 4 distinct values, pet_breed is a factor with 6 levels, happiness is an ordered factor with 4 levels, and happiness_label is an ordered factor with 4 labeled levels. Some important points to note here:\n\nThe factor variables are actually stored as integers under the hood. The three factor variables, but not the name character variable, include a list of the integer values that correspond to each level of the factor. This is the case for the numeric-looking happiness variable too. “1” isn’t 1, but it is mapped to 1.\nThe values of both the name and pet_breed variables are presented in alphabetical order, but only the pet_breed variable is a factor with its values (levels) stored as integers.\nBeyond just being called “Ord.factor” instead of “Factor,” the levels of the ordered factors are in the order we specified, not alphabetical order, made possible by the stored-as-integer thing. They’re not just listed that way, they actually appear with the comparison operators. According to R, not only is “1” &lt; “2”5, “horribly depressed” is objectively less than “mostly numb,” which is less than “pretty ok,” which is less than “weirdly great.”\nThe string-looking happiness_label variable no longer has its original level names (“1”, “2”, “3”, “4”). Unlike in some other programming languages (e.g., Stata), renaming the levels of a factor variable in R replaces the original names instead of adding new ones. Check out the documentation for ?factor to see how the levels and labels arguments work together.\n\nAs complicated as this has already gotten, we’ll get into even more depth about working with factor variables in ?sec-forcats using the forcats package.\n\n\n5.2.4.6 Dates & Date-Times\nDates and date-times are special data types in R used to represent points in time. Dates represent calendar dates (year, month, day) without a specific time of day, while date-times – as you might expect – include both the date and the time (hours, minutes, seconds). Date-times are also called POSIX objects in R.\nYou can create date and date-time objects using the as.Date() and as.POSIXct() functions, respectively. These values are stored as numeric values representing the number of days (for dates) or seconds (for date-times) since a reference date (January 1, 1970).\n\nmy_date &lt;- as.Date(\"1988-06-07\")\nmy_datetime &lt;- as.POSIXct(\"2016-03-19 14:30:00\")\nclass(my_date)      # \"Date\"\n\n[1] \"Date\"\n\nclass(my_datetime)  # \"POSIXct\" \"POSIXt\"\n\n[1] \"POSIXct\" \"POSIXt\" \n\n\nYou can perform various operations on date and date-time objects, such as calculating the difference between two dates, extracting specific components (like year or month), and formatting them for display.\n\n# Calculate the difference between two dates\nyour_date &lt;- as.Date(\"1991-04-10\")\nyour_date - my_date  # Time difference of 1037 days\n\nTime difference of 1037 days\n\nmy_date - your_date # Time difference of -1037 days\n\nTime difference of -1037 days\n\nyour_datetime &lt;- as.POSIXct(\"2016-03-18 21:59:00\")\nyour_datetime - my_datetime  # Time difference of -16.51667 hours\n\nTime difference of -16.51667 hours\n\nmy_datetime - your_datetime # Time difference of 16.51667 hours\n\nTime difference of 16.51667 hours\n\n# You can extract the numeric component, but it won't give you the units\nas.numeric(my_datetime - your_datetime) # 16.51667 ?? Hours? days? seconds? years?\n\n[1] 16.51667\n\nclose_datetime &lt;- as.POSIXct(\"2016-03-19 14:31:20\")\nmy_datetime - close_datetime  # Time difference of -1.333333 mins\n\nTime difference of -1.333333 mins\n\nas.numeric(my_datetime - close_datetime) # -1.333333 ?? Hours? days? seconds? years?\n\n[1] -1.333333\n\n\nIt shouldn’t be hard to wrap your head around what dates and times are, but they can be surprisingly obnoxious to work with. Daylight savings, time zones, leap years, regional formatting for dates, 12 vs 24 hour clocks…things get complicated fast. Thankfully there are dedicated packages to make working with dates and times easier, including chron, hms, and the tidyverse’s lubridate, which we’ll cover in ?sec-lubridate.\n\n\n5.2.4.7 Missing data (NA)\nIn R, missing data points are represented by the special value NA, which stands for “Not Available.” Missing data is not actually a data type, but this is as good a spot as any to mention it.\nYou can assign NA to any variable, regardless of its data type:\nmissing_numeric &lt;- NA\nmissing_character &lt;- NA\nmissing_logical &lt;- NA\n# etc.\nThat means that NA can be part of data structures that can only contain a single data type, like vectors and matrices:\nnumeric_vector &lt;- c(1, 2, NA, 4, 5)\ncharacter_vector &lt;- c(\"a\", \"b\", NA, \"d\", \"e\")\nlogical_vector &lt;- c(TRUE, FALSE, NA, TRUE, FALSE)\nmatrix_with_na &lt;- matrix(c(1, 2, NA, 4, 5, NA), nrow = 2)\nHere are some things that are not missing data:\n\nThe string \"NA\"\nThe empty string \"\"\nLogical FALSE\nNumeric 0\nNULL, which is a special object representing any undefined or non-existent value\nAnything that other programming languages use to represent missing data other than NA6:\n\nPython: None\nSQL: NULL\nStata: .\nSPSS: nothing/blank\nExcel: nothing/blank or #N/A\nMATLAB: NaN\n\n\nThere’s also NaN (Not a Number), which is a special numeric value representing undefined numeric values (like dividing by 0). R will handle NA and NaN similarly in many contexts, but they’re not equivalent.\nYou can check whether a value is NA using the is.na() function, which returns a logical value (TRUE or FALSE):\nis.na(missing_numeric)      # TRUE\nis.na(missing_character)    # TRUE\nis.na(missing_logical)      # TRUE\nis.na(NA)                   # TRUE\nis.na(\"NA\")                 # FALSE\nis.na(\"\")                   # FALSE\nis.na(NaN)                  # TRUE -- don't think too much about it...\nis.na(NULL)                 # logical(0)\nWhen you read in any new data, check that missing data is represented as NA and not something else. R will often, but not always, automatically convert other representations of missing data to NA when importing data. It’s particularly unreliable when the data being read in has anything non-tabular squashed into a tabular format, like comments, titles, and metadata.\nIf you have missing data represented in a different way, you can convert it to NA using functions like na_if() from the dplyr package or replace() from base R.\n\n\n\n5.2.5 Operators\nOperators are symbols that tell R to perform specific operations on one or more values or variables. These are usually separated into 3 categories: arithmetic, comparison, and logical. There are also a handful of others I’m lumping together for simplicity.\n\n5.2.5.1 Arithmetic\nArithmetic operators are exactly what you think they are: they do math. Most or all of these should look very familiar, since they are either similar or identical to the basic math operators you learned in math class.\n\n\n\nOperator\nDescription\nExample\nOutput\n\n\n\n\n+\nAddition\n3 + 5\n8\n\n\n-\nSubtraction\n10 - 4\n\n\n\n*\nMultiplication\n6 * 7\n42\n\n\n/\nDivision\n20 / 4\n5\n\n\n^\nExponentiation (power)\n2 ^ 3\n8\n\n\n%%\nModulo (remainder of division)\n10 %% 3\n1\n\n\n\nThe one operator from this group that might not be familiar is modulo (aka modulus or just “mod”). The result of the modulo operation is just the remainder left over after dividing one number by another.\n\n\n5.2.5.2 Comparison\nComparison or relational operators compare two values or variables and return a logical value (TRUE or FALSE) based on the result of the comparison. These should also be familiar from math class.\n\n\n\nOperator\nDescription\nExample\nOutput\n\n\n\n\n==\nEqual to\n5 == 5\nTRUE\n\n\n!=\nNot equal to\n5 != 3\nTRUE\n\n\n&gt;\nGreater than\n7 &gt; 4\nTRUE\n\n\n&lt;\nLess than\n3 &lt; 8\nTRUE\n\n\n&gt;=\nGreater than or equal to\n6 &gt;= 6\nTRUE\n\n\n&lt;=\nLess than or equal to\n2 &lt;= 5\nTRUE\n\n\n\nTwo quick things to point out with these:\n\nThe equal sign is ==, not =. A single equal sign is an assignment operator, similar to &lt;-. More on that below.\nThe not equal sign is !=, which is usually represented with “=/=” or “≠” outside of programming.\n\n\n\n5.2.5.3 Logical\nLogical operators combine or modify logical values (TRUE or FALSE). There are 3 other logical operators:\n\n\n\n\n\n\n\n\n\nOperator\nDescription\nExample\nOutput\n\n\n\n\n&\n“and”: both sides of the operators evaluate to TRUE\nTRUE & FALSE\nFALSE\n\n\n|\n“or”: at least one side of the operator evaluates to TRUE\nTRUE | FALSE\nTRUE\n\n\n!\n“not”: the opposite of something’s logical evaluation\n!TRUE\nFALSE\n\n\n\nIt helps to think of the ! as the word “not”: != is “not equal to”. !TRUE is FALSE. is.na(x) means “is x missing?” (true or false), and !is.na(x) means “is x not missing?” (true or false, the opposite of is.na(x)).\nThe & and | operators come in two flavors: single or (& and |) and double (&& and ||). The oversimplified difference is that single operators work element-wise on vectors, while double operators “short-circuit” and only evaluate the first element of each vector work correctly with scalars. The behavior of short-circuit operators in R has changed, leaving much of the documentation and support resources out of date. Confusing at best and often just flat out incorrect. Dig into this difference if you want or need to, but for most purposes, you can just use the single operators (& and |).7 Be sure to look at resources for R 4.3.0 or later.\n\n\n5.2.5.4 “Special” and miscellaneous\n\n\n\n\n\n\n\n\n\nOperator\nDescription\nExample\nOutput\n\n\n\n\n&lt;- or =\nAssignment operator\nx &lt;- 5 or x = 5\nAssigns the value 5 to the variable x\n\n\n:\nCreate a sequence of integers\n1:5\nc(1, 2, 3, 4, 5)\n\n\n[ ]\nSubset elements of a vector, list, or data frame by position or name\nlist(first = 1, second = 2)[2]\n&gt; $second &gt; [1] 2\n\n\n[[ ]]\nExtract a single element from a list by position or name\nlist(first = 1, second = 2)[[2]]\n2\n\n\n$\nExtract a single element from a list or data frame by name\nlist(first = 1, second = 2)$second\n2\n\n\n|&gt; or %&gt;%\nPipe operator to pass the output of one function as the input to another\ndata |&gt; filter(condition)\nPasses data as the first argument to filter()\n\n\n\nWe’ll talk more about assignment and indexing in ?sec-r-programming. WYNTKN:\n\n&lt;- takes a value on the right and assigns it to a variable name on the left. Don’t use = for assignment outside of functions.\nwhatever[x,y] gets you the value in the xth row and yth column of a data frame or matrix. whatever[x] gets you the xth element of a vector or list.\n\n\n\n5.2.5.5 Infix\nInfix functions are not operators. They are functions that take commonly used functions and allow you to use a special syntax to call them. Typically, you call a function by the name and a list of arguments contained in parentheses: funcname(arg1, arg2, ...). Infix functions let you call a function by placing the function name between the arguments, like arg1 funcname arg2, the same way that operators work.\nYou can recognize these by the percent signs (%) surrounding the “operator” name. Most shortcuts like this are not part of base R, and some packages will have versions of these shortcuts that overlap or conflict with each other, so be very careful to stay aware of where each one is coming from.\nHere are just a few examples:\n\n\n\n\n\n\n\n\n\n\n“Operator”\nDescription\nExample\nOutput\nPackage(s)\n\n\n\n\n%in%\nCheck if elements of one vector are present in another vector\n3 %in% c(1, 2, 3, 4, 5)\nTRUE\nbase R\n\n\n%like%\nCheck if elements of one character vector are present in another character vector using pattern matching (similar to SQL LIKE)\n\"cat\" %like% c(\"cat\", \"dog\", \"fish\")\nTRUE\ndata.table\n\n\n%&gt;%\nPipe operator to pass the output of one function as the input to another\ndata %&gt;% filter(condition)\nPasses data as the first argument to filter()\nmagrittr, dplyr, tidyverse\n\n\n%&lt;&gt;%\nCompound assignment pipe operator that updates the left-hand side with the result of the right-hand side operation\ndata %&lt;&gt;% filter(condition)\nUpdates data with the result of filter(data, condition)\nmagrittr\n\n\n\nAgain, these are functions, not operators. Learn more about infix functions here.\n\n\n\n5.2.6 Comments\nComments are segments of text ignored by R when it runs your code. The pound sign # tells R to ignore anything that follows on the same line.\nUse comments often to add plain-English, collaborator-friendly explanations for what your code does. You can temporarily comment out code if 1) you think you may delete it later or 2) there will be some cases where you want R to ignore the code (leave commented) but other times you want it to run (uncomment).\nAdd long comments by starting the line with 1 or more #. For blocks of comments that span multiple lines, start every line with a #.\nPut a # before code to temporarily “comment it out.” This code will be ignored by R until you remove the #.\nComments can begin in the middle of a line. R will run everything before the # and ignore everything that follows.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>R Language Basics</span>"
    ]
  },
  {
    "objectID": "chapters/r-language-basics.html#r-data-structures",
    "href": "chapters/r-language-basics.html#r-data-structures",
    "title": "5  R Language Basics",
    "section": "5.3 R data structures",
    "text": "5.3 R data structures\n\n5.3.1 Vectors\nmultiple scalar objects (values) stored in a particular order; values can be any data type including NA\n\n\n5.3.2 Lists\n\n\n5.3.3 Matrices\nmultiple vector objects of a single data type stored in a particular order; combine vectors as columns (cbind()) or rows (rbind()), or distribute a vector across named rows and columns (matrix())\n\n\n5.3.4 Data frames\nData frames are lists of equal-length vectors: \u000bdata.frame()\u000b The heart &lt;3 of R Vectors can use different data types Values within each vector (column) are the same data type Technically a list, but takes a tabular format (like a matrix)\u000b Tibbles are simplified data frames: \u000btibble()\u000b Used in the tidyverse (more later) For our (and most) purposes, can be treated interchangeably with data frames\n\n\n5.3.5 Tibbles",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>R Language Basics</span>"
    ]
  },
  {
    "objectID": "chapters/r-language-basics.html#learn-more",
    "href": "chapters/r-language-basics.html#learn-more",
    "title": "5  R Language Basics",
    "section": "5.4 Learn More",
    "text": "5.4 Learn More",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>R Language Basics</span>"
    ]
  },
  {
    "objectID": "chapters/r-language-basics.html#footnotes",
    "href": "chapters/r-language-basics.html#footnotes",
    "title": "5  R Language Basics",
    "section": "",
    "text": "I study language. I’m allowed to talk nonsense like this.↩︎\nMixing up the words of a sentence makes it mean something else or nothing at all.↩︎\nAnd I assure you, it’s a lot more than a single Junimo plush.↩︎\nIf you run class(class(3.14)), it will return \"character\".↩︎\nAs intuitive as it may seem, this needn’t be the case, since \"1\" is not the same as the integer 1.↩︎\nI have primarily used R for many years and am relying on secondary sources for some of this info. If you have experience with other languages and see any errors here, please let me know!↩︎\nI’m pretty sure that in my years of using R, I have never needed to explicitly use the double and/or.↩︎",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>R Language Basics</span>"
    ]
  },
  {
    "objectID": "chapters/packages.html",
    "href": "chapters/packages.html",
    "title": "6  Packages",
    "section": "",
    "text": "6.1 Packages Overview\nR packages (also known as libraries) are collections of R functions, data, and documentation bundled together to extend the functionality of R. Without packages, you are working with base R, a core set of “built-in” functions and data types.\nBase R includes:\nBut base R is not sufficient for most data analysis tasks beyond the most basic.\nThankfully, that’s not a problem. The (relative) simplicity of base R is a feature, not a bug. Base R provides the tools to build progressively more complex and specialized functionality, and the open-source nature of R makes it possible for anyone (literally anyone!) to create and share the more complex functions they develop in the form of packages.\nThese collections of functions can be designed for extremely specific use cases or broad application for use across many contexts.\nLet’s see some examples of packages for two different purposes, from very broad to very narrow in each category:\nThese are all packages that I personally use, some (much) more than others. Some of these are so ubiquitous that you can forget they aren’t base R (looking at you, readr); others I’d be willing to bet 99% of readers of this book have never heard of and would never have occasion to use (phonfieldwork, xkcd1).\nComing back to thinking about packages vs. base R, it’s even more package-y than it sounds. When we talk about “base R,” we’re actually talking about a collection of packages including base, stats, utils, and graphics, among others. Yes, one of the packages in “base R” is called base, which is admittedly confusing. If you’re curious, you can spot base R packages in your packages pane. They are the ones that (thankfully) don’t have an option to delete them. You can also view a list of base packages with:\nWhat you absolutely need to take away from this is that packages are the key to R’s power and flexibility. Packages are R. They are not extra. They are the whole premise of R as a programming language. Don’t be afraid to seek out packages that do what you need, to play around with popular packages even if you don’t have a use for them now, or to try your hand at creating your own.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "chapters/packages.html#packages-overview",
    "href": "chapters/packages.html#packages-overview",
    "title": "6  Packages",
    "section": "",
    "text": "Key data structures, such as vectors, lists, matrices, and data frames\nOperators, so you can do basic math, evaluate logical comparisons, and create data objects\nFunctions that sufficiently carry out common tasks, like reading in tabular data, extracting and manipulating object elements, performing simple summary statistics (and much more)\nFunctions that allow a basic implementation of most data analysis tasks, such as reading in data, manipulating data, and plotting data\n\n\n\n\n\n\n\n\nPackage(s)\nScope\nDescription / Use Case\n\n\n\n\nData read-in and write-out\n\n\n\n\nreadr\nBroad\nImport/export of tabular delimited data\n\n\nhaven, foreign\nMedium\nLoad data from proprietary formats (Stata, SPSS, SAS)\n\n\ngooglesheets4\nNarrow, but common\nImport/export of Google Sheets\n\n\nDBI\nNarrow\nImport/export of databases (SQL, etc.)\n\n\nphonfieldwork\nVery narrow\nImport/export of phonetic fieldwork data (Praat, ELAN, etc.)\n\n\nData visualization\n\n\n\n\nggplot2\nBroad\nGrammar of graphics for flexible and complex visualizations\n\n\nplotly\nBroad, but less popular\nInteractive visualizations\n\n\nvcd\nMedium\nTools for visualizing categorical data\n\n\nggalluvial, ggmosaic\nNarrow\nSpecialized plots with ggplot grammar (alluvial, mosaic)\n\n\nxkcd, ggsci\nVery narrow\nApply pop culture-inspired styles to plots\n\n\n\n\n\nrownames(installed.packages(priority = \"base\"))",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "chapters/packages.html#installing-attaching-loading-packages",
    "href": "chapters/packages.html#installing-attaching-loading-packages",
    "title": "6  Packages",
    "section": "6.2 Installing, attaching, loading packages",
    "text": "6.2 Installing, attaching, loading packages\nTo use functions from a package, you need to install it to your computer and then either attach the package to your workspace or load individual functions.\nThink of this like using cloud storage. Here at UChicago, we have free unlimited storage via Box2. To access your files on your computer, you need to download and install the Box Drive app. You can download a folder to your computer to open the files within it any time. Alternatively, you can open a single file directly from the cloud.\nIn this analogy, installing the package with install.packages() is like downloading the Box Drive app. There’s just no way to get to the contents without it.3\nAttaching the package with library() is like downloading a folder from Box to your computer. All the contents of the package (like files in a folder) are there and ready to use.\nLoading a single function with :: is like opening a single file directly from the cloud. You can access the contents of that file without downloading it to your computer, but you need to re-access it in the cloud every time you want to open it. You can’t access any other files in the folder without downloading them first.\nIn practice, we typically say “loading” instead of “attaching,” but you should be aware of the difference.\n\n6.2.1 Installing packages\nInstall a package with the base R function install.packages(). This function takes a character string with the name of the package you want to install. For example, to install the dplyr package, you would run:\ninstall.packages(\"dplyr\")\nThis will download the package from CRAN (the Comprehensive R Archive Network) and install it on your system. You only need to do this the first time you use a package. You do not need to reinstall a package at every new session, but you can use this same command to update a package to the latest version if one is available.\nThe packages pane shows you a list of installed packages. You can also install directly from the packages pane, but you shouldn’t, so I’m not going to tell you how.\n\n\n6.2.2 Attaching (loading) packages\nOnce a package is installed, you need to attach it into your R session to use its functions. You can do this with the library() function, which takes one arguement: the name of the package object you want to attach. For example, to attach the dplyr package, you would run:\nlibrary(dplyr)\nThe library() function attaches functions from the package to your workspace, but you’ll almost always hear this referred to as “loading” a package. The distinction matters conceptually, but in practice you can just think about this as “loading” a package.\nWhile you only need to install a package once, you need to attach/load it every time you start a new R session and want to use its functions freely.\nNotice that while install.packages() takes a character string (in quotes) as an argument, library() takes the name of the package object itself. Once the package is installed, it is available as an object in your R environment, so you can refer to it by name without quotes.\n\n\n6.2.3 Loading functions\nIf you don’t attach a whole package during your R session you can still “load” just its functions individually as you use them by specifying the containing package with :: syntax. For example, if you wanted to use the filter() function from the dplyr package without attaching it, you could run:\ndplyr::filter()\nThis will load the filter() function from the dplyr package without attaching the entire package. This is useful if you want to use a function from a package without loading all of its functions into your environment, or if you want to avoid masking issues with functions that have the same name in different packages.\n\n\n6.2.4 Dependencies\nThe same way that package functions are built using base R functions, packages also frequently (usually) build on functions from other packages. When a package uses functions from another package, that other package is its dependency.\nThere are two big categories of dependencies, hard and soft dependencies. Hard dependencies are required. Functions in the package simply won’t work without them. Soft dependencies are recommended to get the most out of the package, but not strictly necessary. We’ve got three flavors of dependencies in R:\n\nDepends: Packages that must be installed and attached for the package to work\nImports: Packages that must be installed (but not attached) for the package to work\nSuggests: Packages that are not required for the package to work, but are recommended for full functionality\n\n\n\n6.2.5 More on packages\n\n6.2.5.1 Install isn’t working!\nThe install.packages() function only works with packages that are available on CRAN. The vast majority of packages are available this way, but not all. For example, the citr package we will use for easy citation management with Quarto is not available on CRAN due to some CRAN-specific requirements, but is still actively maintained and functional.\nIn cases like this we can install the package directly from its GitHub repository using the devtools package. What a funny coincidence that we just installed this package! To install a package from GitHub, you can use the devtools::install_github() function which takes a string argument of everything in the GitHub repo URL following “github.com/”. For example, to install the citr package, you would run:\ndevtools::install_github(\"crsh/citr\")\nJust because a package is not on CRAN does not mean it is not useful, reliable, or trustable – citr is a great example. Still, you should be cautious with packages that are not on CRAN, as they may not have the same level of scrutiny or quality control as those that are.\nIf needed, you can also learn more about alternative ways to install packages.\n\n\n6.2.5.2 Same function, different packages, oh no!\nFunction not behaving as expected? Did it do one thing yesterday and something totally different today? The most likely reason is that you messed up your code between then and now. The second most likely reason is that you have two packages loaded that both have a function with the same name, and one of them is masking the other.\nAnyone can make a package, and packages have lots of overlap in use. There are going to be lots of things that do exactly the same thing but are called different things in different packages. There are also just a lot of functions that are going to be named the same thing. Neither situation is a problem, but you do need to be able to recognize when it happens. Once you do, it’s easy to address.\nMy go-to example for the many-names-same-thing situation is running ANOVAs.\nThere are a lot of packages that have functions for running ANOVAs that all do (basically) the same thing, but they have different names. For example, aov() in base R, anova() in stats, anova_test() in rstatix, and anova.psych() in psych. They all run ANOVAs, but they are different functions with different arguments and outputs. You just need to know which one you want to use and how to use it.\nIf you need to run an ANOVA, you can choose the one that’s best suited to your needs. If you just have a simple comparison of means to run, you can go with base aov(). If you want to run a more complex ANOVA with post-hoc tests, you might want to use anova_test() from rstatix. If you want to run a repeated measures ANOVA, you might want to use anova.psych() from the psych package. If you want to use ANOVA to compare model fit, you could use anova() from stats.\nIt’s a good thing to have a lot of options, but it’s up to you to keep straight which function does what, where it comes from, how to implement it, and how to interpret the output. Keep in mind that your collaborators (including future-you) may not have the same familiarity or preferences as you do, so it’s a good idea to add comments to your code about why you chose a particular function or package for a specific task.\nMore confusing is the case where two packages have functions with the same name that do somewhat or very different things. Mixed effects linear models get me here. The lme4 package is the most popular package for running mixed effects models, and it includes a function called lmer(). This particular lmer() has a problem, though: it doesn’t include \\(p\\)-values. Despite my personal objections to the obsession with \\(p\\)-values, the reality is that I almost always need to report them. The lmerTest package has a function that does return \\(p\\)-values…also called lmer(). When I call lmer(), what is R to do?\nThe simplest solution is to just use one package or the other. If I have lmerTest loaded (more accurately, attached) but not lme4, then lmer() will refer to the lmerTest function. Neat.\nOk fine, but lme4 has a lot of functionality beyond this one specific lmer() function that I want to be able to take advantage of. I want both packages loaded. In this case, R uses masking to decide which package’s function to use. When you attach a package to your session, R attaches all its packages. When you attach another package, it attaches all its packages – even if there was already a package with the same name attached. The new function masks the old one.\nThe take-away is that you need to pay attention to the order in which you load packages. If I load lme4 first and then lmerTest, I’ll have lmerTest’s \\(p\\)-value version of lmer() by default, but I’ll still have access to everything in lme4 that wasn’t overridden by lmerTest.\nAlternatively or additionally, you can use the :: syntax to specify which package’s function you want to use. Remember that :: searches your installed packages for the function, so you can just specify precisely which version of the function to use and when. This gets very cumbersome, so it’s not something you should default to, but it has important advantages. It’s explicit, so you-the-user and your collaborators know exactly which function is being used. It takes package loading order out of the equation. It also lets you use functions from packages that are not attached, so you can avoid the masking issue entirely.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "chapters/packages.html#commonly-used-packages-in-d2m-r",
    "href": "chapters/packages.html#commonly-used-packages-in-d2m-r",
    "title": "6  Packages",
    "section": "6.3 Commonly used packages in D2M-R",
    "text": "6.3 Commonly used packages in D2M-R\nIn this course, we’ll rely heavily on a set of packages that are commonly used in data analysis, mostly pulling from the tidyverse ecosystem. We’ll also use a handful of packages that are more specialized for the tasks we want to accomplish in our data to manuscript workflow, especially geared toward psychologists and other quantitative social scientists.\nYou should install these packages now, and take some time to get a surface level familiarity with them by reading their documentation. Note that tidyverse packages can be installed and loaded either individually or all together with the tidyverse package.\n\n6.3.1 Required Packages\n\n\n\nPackage Name\nDescription\nDocumentation Link\n\n\n\n\ntidyverse\nEcosystem of packages for data manipulation, visualization, and analysis; includes core tv packages\ntidyverse.org\n\n\ntidyverse: dplyr\nData manipulation and transformation\ndplyr.tidyverse.org\n\n\ntidyverse: forcats\nTools for working with categorical variables (factors)\nforcats.tidyverse.org\n\n\ntidyverse: ggplot2\nData visualization using the grammar of graphics\nggplot2.tidyverse.org\n\n\ntidyverse: lubridate\nTools for working with dates and times\nlubridate.tidyverse.org\n\n\ntidyverse: readr\nFast and friendly reading of rectangular data\nreadr.tidyverse.org\n\n\ntidyverse: stringr\nConsistent, simple tools for working with strings\nstringr.tidyverse.org\n\n\ntidyverse: tidyr\nData tidying: reshaping and cleaning datasets\ntidyr.tidyverse.org\n\n\nbibtex\nBibTeX tools for R (bibliography management)\ncran.r-project.org/package=bibtex\n\n\ncitr\nRStudio add-in to insert citations\ngithub.com/crsh/citr\n\n\nDescTools\nTools for descriptive statistics\ncran.r-project.org/package=DescTools\n\n\ngt\nEasily create presentation-ready tables\ngt.rstudio.com\n\n\nknitr\nDynamic report generation in R\nyihui.org/knitr/\n\n\nlme4\nLinear and generalized linear mixed-effects models\ncran.r-project.org/package=lme4\n\n\npsych\nProcedures for psychological, psychometric, and personality research\ncran.r-project.org/package=psych\n\n\nquarto\nTools for working with the Quarto markdown publishing system\nquarto.org\n\n\nrmarkdown\nAuthoring dynamic documents with R Markdown\nrmarkdown.rstudio.com\n\n\nusethis\nAutomate package and project setup tasks\nusethis.r-lib.org\n\n\n\n\n\n6.3.2 Suggested Additional Packages\n\n\n\nPackage Name\nDescription\nDocumentation Link\n\n\n\n\nbroom\nConvert statistical analysis objects into tidy tibbles\nbroom.tidymodels.org\n\n\ndata.table\nFast data manipulation and aggregation\nrdatatable.io\n\n\nflextable\nFunctions for reporting tabular results in R Markdown and Word\ndavidgohel.github.io/flextable/\n\n\nhaven\nImport and export of SPSS, Stata, and SAS files\nhaven.tidyverse.org\n\n\njanitor\nSimple tools for examining and cleaning dirty data\nsfirke.github.io/janitor/\n\n\nkableExtra\nConstruct complex tables in R Markdown\nhaozhu233.github.io/kableExtra/\n\n\npapaja\nAPA style manuscript preparation with R Markdown\ncrsh.github.io/papaja/\n\n\npwr\nPower analysis for general linear models\ncran.r-project.org/package=pwr\n\n\nRColorBrewer\nColor palettes for maps and figures\ncran.r-project.org/package=RColorBrewer\n\n\npatchwork\nCombine separate ggplot2 plots into the same graphic\npatchwork.data-imaginist.com\n\n\nvcd\nVisualizing categorical data\ncran.r-project.org/package=vcd\n\n\nggsci\nScientific journal and sci-fi movie color palettes for ggplot2\nnanx.me/ggsci/\n\n\npurrr\nFunctional programming tools\npurrr.tidyverse.org",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "chapters/packages.html#guided-exercise-packages-and-dependencies",
    "href": "chapters/packages.html#guided-exercise-packages-and-dependencies",
    "title": "6  Packages",
    "section": "6.4 Guided Exercise: Packages and Dependencies",
    "text": "6.4 Guided Exercise: Packages and Dependencies\nThe Packages and Dependencies exercise will walk you through the process of installing, attaching, and loading packages in R using the devtools package as an example. You’ll also practice finding and reading documentation, and understanding how dependencies work.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "chapters/packages.html#footnotes",
    "href": "chapters/packages.html#footnotes",
    "title": "6  Packages",
    "section": "",
    "text": "Then again, I’d argue everyone should more enthusiastically integrate xkcd into their work.↩︎\nIf you’re not taking advantage of this, you absolutely should.↩︎\nYes, I’m conveniently ignoring that you can get to files via the web interface, but that’s not the point of this analogy.↩︎",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "chapters/r-programming.html",
    "href": "chapters/r-programming.html",
    "title": "7  Intro to Programming in R",
    "section": "",
    "text": "7.1 Overview\nIn this chapter we will go into a bit more depth on some of what we covered in ?sec-r-language-basics, and introduce some more complicated programming concepts you’re likely to need as a social sciences researcher.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Intro to Programming in R</span>"
    ]
  },
  {
    "objectID": "chapters/r-programming.html#essential-concepts",
    "href": "chapters/r-programming.html#essential-concepts",
    "title": "7  Intro to Programming in R",
    "section": "7.2 Essential concepts",
    "text": "7.2 Essential concepts\n\n7.2.1 Object assignment\nIn R we create variables by assigning a value to a name with the assignment operator &lt;-. Technically you can use = to assign a value to a variable, but you really shouldn’t; &lt;- is the preferred assignment operator in R.\n\n\n7.2.2 Indexing and subsetting with [ ] & $\n\nuse : to create a vector of integers beginning with one number and ending with another\n\n1:5 is equivalent to c(1, 2, 3, 4, 5)\n\nuse [ and ] to select elements of a vector, list, or data frame by position or name\n\nc(1, 10, 3, 1000, 2)[4] returns the fourth element of the vector, 1000\n\nuse , to separate row and column indices when selecting from a data frame or matrix\n\nmtcars[1, ] returns the first row of the mtcars data frame\nmtcars[, 1] returns the first column of the mtcars data frame\nmtcars[1, 1] returns the value in the first row and first column of the mtcars data frame\n\nuse [[ and ]] to select a single list element by position or name\n\nmy_list &lt;- list(first = 1, second = 2); my_list[[2]] returns 2\n\nuse $ to select a list element by name\n\nmtcars$mpg returns the mpg column of the mtcars data frame\nmy_list &lt;- list(first = 1, second = 2); my_list$second returns 2\n\n\nHow are [ and [[ different? [ always returns an object of the same type as the original object, while [[ returns a single element of the object. This starts to matter when you’re working with complex data structures that store multiple data types, like lists, data frames, and model output.\n# Create a list with two elements: a numeric vector and a character vector\nmixed_list &lt;- list(a = 1:5, b = letters[1:5])\nIf you print the list, you’ll see both elements:\n&gt; mixed_list\n$a\n[1] 1 2 3 4 5\n\n$b\n[1] \"a\" \"b\" \"c\" \"d\" \"e\"\nUsing single brackets to select the first element returns a list with one element (the numeric vector):\n&gt; mixed_list[1]\n$a\n[1] 1 2 3 4 5\n\n&gt; class(mixed_list[1])\n[1] \"list\"\nUsing double brackets to select the first element returns just the numeric vector itself:\n&gt; mixed_list[[1]]\n[1] 1 2 3 4 5\n\n&gt; class(mixed_list[[1]])\n[1] \"integer\"\n# Create a gradebook dataframe\nspanish101 &lt;- data.frame(\n    name = c(\"Annie\", \"Troy\", \"Abed\", \"Kevin\"),\n    age = c(20:22, 99),\n    score = c(101, 69, 90, -10)\n)\n\nspanish101[3, \"score\"]  # returns 90\n\nspanish101$score[1]     # returns 101\n\nspanish101[spanish101$name == \"Troy\", \"age\"]  # returns 21\n\n\n7.2.3 Seeds and randomization\n\n\n7.2.4 (more base R essentials)",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Intro to Programming in R</span>"
    ]
  },
  {
    "objectID": "chapters/r-programming.html#sec-programming-functions",
    "href": "chapters/r-programming.html#sec-programming-functions",
    "title": "7  Intro to Programming in R",
    "section": "7.3 Functions in R",
    "text": "7.3 Functions in R\nWe introduced functions in ?sec-function-basics, and you’ll have seen them used throughout course materials so far. There’s just no sensible way to talk about anything in R without implicitly using some functions, so hopefully by now you’ve picked up on the gist of how they work. You can honestly get pretty just using functions without understanding them, but obviously you can get a lot farther if you do, so let’s talk about them a bit more.\nHere’s a thing that is definitely totally hypothetical and has never happened:\n\nI ignore my work and start playing my favorite video game.\n\n“Ignoring” and “playing” are functions, and “my work” and “my favorite video game” are the objects those functions are acting on.\n\n7.3.1 Function arguments and return values\nWhen you want to do the action (or more analogous to R, when you want to tell someone to do the action), you’ll often want to add some more information to specify what exactly you want to do the action to or how to do it.\n\n\n7.3.2 Writing functions\n\n\n7.3.2.1 Anonymous functions\nAn anonymous function is a function that is defined without being assigned to a name. This is useful for short, one-off functions that you don’t need to reuse elsewhere in your code. You’re most likely to need anonymous functions when you’re using functions that take other functions as arguments, like sapply()1. For example:\n# Use an anonymous function to square each element of a vector\nsquare_them_all &lt;- sapply(1:5, function(x) x^2)\nprint(square_them_all)  # returns: [1]  1  4  9 16 25\nThe sapply() function takes a function as an argument and applies it to each element of a vector or list (in this case, the series of numbers from 1 to 5). We define the function we want to apply (in this case, squaring the input x) directly within the call to sapply(), without giving it a name. The syntax for anonymous functions is simplified: function(list, of, arguments) theFunctionActions.\n\n\n\n\n7.3.3 Scope and environments\nWe introduced the idea of your environment in Section 5.2.1. Before writing functions, we need to talk about environments plural.\nEnvironments have scopes. If you look at your environment pane, notice that all these objects are in your global environment. This is the top-level environment that contains all of the objects you create in your R session. Anything existing in your global environment can be referenced from anywhere in your R session.\nIf you click the dropdown that says “Global Environment,” you’ll see a list of environments associated with any packages you’ve loaded in your R session. You can explore these package environments to see what their values, functions, and example datasets look like behind the scenes.\nThe other scope of environment you’ll come across is the function environment. When you call a function, R creates a new environment for that function to run in. Anything defined within that function environment is local to that function and cannot be accessed from outside the function. When the function finishes running, its environment is destroyed, and any objects created within it are lost unless they are explicitly returned by the function.\nWhen you write your own functions, you’ll create variables that exist only within the scope of that function’s environment. Functions that you run within that function can access these function-scoped variables, but nothing outside the function can.\nFor example:\nadd_y &lt;- function(x) {\n    y &lt;- 2  # 'y' is created in the function environment\n    paste(\"Adding\", x, \"and\", y, \"makes\", x + y)\n}\n\nadd_y(3) # returns: [1] \"Adding 3 and 2 makes 5\"\n\n3 + y # Error: object 'y' not found\nWe defined y inside the function add_y()’s local environment. As long as we’re inside that function, we can use y just fine. We can print y and do math with it using the value we passed to x.\nIf we try to do the same math outside the function, we get an error. y doesn’t exist in our global environment, so R can’t find it. You can confirm this by looking in your environment pane; y won’t be there.\nScoping is important in the other direction as well. If a function tries to use a variable that isn’t defined within its own environment, R will look for that variable in the global environment. For example:\nz &lt;- 5  # 'z' is created in the global environment\n\nmultiply_by_z &lt;- function(x) {\n    paste(\"Multiplying\", x, \"by\", z, \"makes\", x * z)\n}\nmultiply_by_z(3) # returns: [1] \"Multiplying 3 by 5 makes 15\"\nSince we defined z globally (take a look in your environment pane to see it), we could reference it within the function without to explicitly defining there or passing it as an argument. If we hadn’t defined z globally, calling multiply_by_z(3) would have resulted in an error because z wouldn’t exist in either the function’s local environment or the global environment.\nAlthough this works, you can probably see why it’s not a great idea to rely on global variables within functions. For one thing, it means you need to redefine those global variables every time you start a new R session. For another, it just kind of defeats the point of functions! Functions are supposed to be self-contained and reusable across contexts. Any objects that a function needs to work should be defined within the function or passed to it as arguments so it can work independently of your global environment.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Intro to Programming in R</span>"
    ]
  },
  {
    "objectID": "chapters/r-programming.html#sec-control-flow",
    "href": "chapters/r-programming.html#sec-control-flow",
    "title": "7  Intro to Programming in R",
    "section": "7.4 Control flow",
    "text": "7.4 Control flow\n\n7.4.1 Logic evaluation\n\n\n7.4.2 Conditional statements\n\n7.4.2.1 if else\n\n\n7.4.2.2 case_when\n\n\n\n7.4.3 Loops\n\n7.4.3.1 for loops\n\n\n7.4.3.2 while loops",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Intro to Programming in R</span>"
    ]
  },
  {
    "objectID": "chapters/r-programming.html#sec-regex",
    "href": "chapters/r-programming.html#sec-regex",
    "title": "7  Intro to Programming in R",
    "section": "7.5 Regular expressions",
    "text": "7.5 Regular expressions\n\n7.5.1 What is regex? What’s the point?\n\n\n7.5.2 Basic syntax\n\n\n7.5.3 Common use cases",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Intro to Programming in R</span>"
    ]
  },
  {
    "objectID": "chapters/r-programming.html#learn-more",
    "href": "chapters/r-programming.html#learn-more",
    "title": "7  Intro to Programming in R",
    "section": "7.6 Learn More",
    "text": "7.6 Learn More",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Intro to Programming in R</span>"
    ]
  },
  {
    "objectID": "chapters/r-programming.html#guided-exercise-create-a-hello_world-function",
    "href": "chapters/r-programming.html#guided-exercise-create-a-hello_world-function",
    "title": "7  Intro to Programming in R",
    "section": "7.7 Guided Exercise: Create a hello_world() function",
    "text": "7.7 Guided Exercise: Create a hello_world() function",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Intro to Programming in R</span>"
    ]
  },
  {
    "objectID": "chapters/r-programming.html#guided-exercise-the-programmers-groceries",
    "href": "chapters/r-programming.html#guided-exercise-the-programmers-groceries",
    "title": "7  Intro to Programming in R",
    "section": "7.8 Guided Exercise: The programmer’s groceries",
    "text": "7.8 Guided Exercise: The programmer’s groceries\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\n\nggplot(iris) +\n    aes(x = Sepal.Length, y = Sepal.Width, color = Species) +\n    geom_point() +\n    theme_minimal()",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Intro to Programming in R</span>"
    ]
  },
  {
    "objectID": "chapters/r-programming.html#footnotes",
    "href": "chapters/r-programming.html#footnotes",
    "title": "7  Intro to Programming in R",
    "section": "",
    "text": "Run ?sapply in your R console to see the documentation for this function.↩︎",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Intro to Programming in R</span>"
    ]
  },
  {
    "objectID": "chapters/tidyverse.html",
    "href": "chapters/tidyverse.html",
    "title": "8  Welcome to the Tidyverse!",
    "section": "",
    "text": "9 Overview of the Tidyverse & tidy data",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Welcome to the Tidyverse!</span>"
    ]
  },
  {
    "objectID": "chapters/tidyverse.html#the-tidy-ecosystem",
    "href": "chapters/tidyverse.html#the-tidy-ecosystem",
    "title": "8  Welcome to the Tidyverse!",
    "section": "9.1 The tidy ecosystem",
    "text": "9.1 The tidy ecosystem",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Welcome to the Tidyverse!</span>"
    ]
  },
  {
    "objectID": "chapters/tidyverse.html#tidy-data-principles",
    "href": "chapters/tidyverse.html#tidy-data-principles",
    "title": "8  Welcome to the Tidyverse!",
    "section": "9.2 Tidy data principles",
    "text": "9.2 Tidy data principles",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Welcome to the Tidyverse!</span>"
    ]
  },
  {
    "objectID": "chapters/tidyverse.html#core-packages-in-the-tidyverse-and-general-functions",
    "href": "chapters/tidyverse.html#core-packages-in-the-tidyverse-and-general-functions",
    "title": "8  Welcome to the Tidyverse!",
    "section": "9.3 Core packages in the Tidyverse and general functions",
    "text": "9.3 Core packages in the Tidyverse and general functions",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Welcome to the Tidyverse!</span>"
    ]
  },
  {
    "objectID": "chapters/tidyverse.html#terminology",
    "href": "chapters/tidyverse.html#terminology",
    "title": "8  Welcome to the Tidyverse!",
    "section": "9.4 Terminology",
    "text": "9.4 Terminology",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Welcome to the Tidyverse!</span>"
    ]
  },
  {
    "objectID": "chapters/tidyverse.html#overview",
    "href": "chapters/tidyverse.html#overview",
    "title": "8  Welcome to the Tidyverse!",
    "section": "10.1 Overview",
    "text": "10.1 Overview\n\n10.1.1 Tabular data - what counts?\n\n10.1.1.1 File types\n\n\n10.1.1.2 R objects, including tibbles\n\n\n\n10.1.2 Reading, writing, rereading (intermediate datasets)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Welcome to the Tidyverse!</span>"
    ]
  },
  {
    "objectID": "chapters/tidyverse.html#reading-data-with-read_-functions",
    "href": "chapters/tidyverse.html#reading-data-with-read_-functions",
    "title": "8  Welcome to the Tidyverse!",
    "section": "10.2 Reading data with read_* functions",
    "text": "10.2 Reading data with read_* functions",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Welcome to the Tidyverse!</span>"
    ]
  },
  {
    "objectID": "chapters/tidyverse.html#writing-data-with-write_-functions",
    "href": "chapters/tidyverse.html#writing-data-with-write_-functions",
    "title": "8  Welcome to the Tidyverse!",
    "section": "10.3 Writing data with write_* functions",
    "text": "10.3 Writing data with write_* functions",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Welcome to the Tidyverse!</span>"
    ]
  },
  {
    "objectID": "chapters/tidyverse.html#other-packages",
    "href": "chapters/tidyverse.html#other-packages",
    "title": "8  Welcome to the Tidyverse!",
    "section": "10.4 Other packages",
    "text": "10.4 Other packages\n\n10.4.1 readxl for Excel files\n\n\n10.4.2 haven for SPSS, SAS, and Stata files\n\n\n10.4.3 googlesheets4 for Google Sheets\n\n\n10.4.4 jsonlite for JSON files\n\n\n10.4.5 DBI and dbplyr for databases",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Welcome to the Tidyverse!</span>"
    ]
  },
  {
    "objectID": "chapters/tidyverse.html#handling-common-importexport-issues",
    "href": "chapters/tidyverse.html#handling-common-importexport-issues",
    "title": "8  Welcome to the Tidyverse!",
    "section": "10.5 Handling common import/export issues",
    "text": "10.5 Handling common import/export issues",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Welcome to the Tidyverse!</span>"
    ]
  },
  {
    "objectID": "chapters/tidyverse.html#introduction-to-dplyr",
    "href": "chapters/tidyverse.html#introduction-to-dplyr",
    "title": "8  Welcome to the Tidyverse!",
    "section": "11.1 Introduction to dplyr",
    "text": "11.1 Introduction to dplyr\n\n11.1.1 the point of pipelines (highly readable, but verbose)\n\n\n11.1.2 The pipe operator (%&gt;%) and magrittr\n\n\n11.1.3 Chaining operations with pipes",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Welcome to the Tidyverse!</span>"
    ]
  },
  {
    "objectID": "chapters/tidyverse.html#selecting-data",
    "href": "chapters/tidyverse.html#selecting-data",
    "title": "8  Welcome to the Tidyverse!",
    "section": "11.2 Selecting data",
    "text": "11.2 Selecting data\n\n11.2.1 select, rename\n\n\n11.2.2 filter\n\n\n11.2.3 arrange",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Welcome to the Tidyverse!</span>"
    ]
  },
  {
    "objectID": "chapters/tidyverse.html#manipulating-data",
    "href": "chapters/tidyverse.html#manipulating-data",
    "title": "8  Welcome to the Tidyverse!",
    "section": "11.3 Manipulating data",
    "text": "11.3 Manipulating data\n\n11.3.1 mutate\n\n\n11.3.2 summarize\n\n\n11.3.3 group_by\n\n\n11.3.4 distinct\n\n\n11.3.5 count",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Welcome to the Tidyverse!</span>"
    ]
  },
  {
    "objectID": "chapters/tidyverse.html#guided-exercise-dplyr-practice",
    "href": "chapters/tidyverse.html#guided-exercise-dplyr-practice",
    "title": "8  Welcome to the Tidyverse!",
    "section": "11.4 Guided Exercise: dplyr practice",
    "text": "11.4 Guided Exercise: dplyr practice",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Welcome to the Tidyverse!</span>"
    ]
  },
  {
    "objectID": "chapters/tidyverse.html#what-counts-as-tidying-data",
    "href": "chapters/tidyverse.html#what-counts-as-tidying-data",
    "title": "8  Welcome to the Tidyverse!",
    "section": "12.1 What counts as “tidying” data?",
    "text": "12.1 What counts as “tidying” data?\n\n12.1.1 Remember what “tidy” means in the tidyverse\n\n\n12.1.2 Tidying is reshaping and systematically cleaning data",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Welcome to the Tidyverse!</span>"
    ]
  },
  {
    "objectID": "chapters/tidyverse.html#reshape-data",
    "href": "chapters/tidyverse.html#reshape-data",
    "title": "8  Welcome to the Tidyverse!",
    "section": "12.2 Reshape data",
    "text": "12.2 Reshape data\n\n12.2.1 pivot_longer\n\n\n12.2.2 pivot_wider\n\n\n12.2.3 cast, melt, gather, spread, etc.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Welcome to the Tidyverse!</span>"
    ]
  },
  {
    "objectID": "chapters/tidyverse.html#combine-and-split-cells",
    "href": "chapters/tidyverse.html#combine-and-split-cells",
    "title": "8  Welcome to the Tidyverse!",
    "section": "12.3 Combine and split cells",
    "text": "12.3 Combine and split cells\n\n12.3.1 unite\n\n\n12.3.2 separate functions",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Welcome to the Tidyverse!</span>"
    ]
  },
  {
    "objectID": "chapters/tidyverse.html#expand-tables",
    "href": "chapters/tidyverse.html#expand-tables",
    "title": "8  Welcome to the Tidyverse!",
    "section": "12.4 Expand tables",
    "text": "12.4 Expand tables\n\n12.4.1 expand\n\n\n12.4.2 complete",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Welcome to the Tidyverse!</span>"
    ]
  },
  {
    "objectID": "chapters/tidyverse.html#handle-missing-values",
    "href": "chapters/tidyverse.html#handle-missing-values",
    "title": "8  Welcome to the Tidyverse!",
    "section": "12.5 Handle missing values",
    "text": "12.5 Handle missing values\n\n12.5.1 drop_na\n\n\n12.5.2 fill\n\n\n12.5.3 replace_na",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Welcome to the Tidyverse!</span>"
    ]
  },
  {
    "objectID": "chapters/tidyverse.html#advanced-nested-data",
    "href": "chapters/tidyverse.html#advanced-nested-data",
    "title": "8  Welcome to the Tidyverse!",
    "section": "12.6 Advanced: Nested data",
    "text": "12.6 Advanced: Nested data\n\n12.6.1 What is nested data and why might you use it?\n\n\n12.6.2 tidyr & nested data\nWe’re not going to cover this in D2MR, but tidyr has functions for creating, reshaping, and transforming nested data.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Welcome to the Tidyverse!</span>"
    ]
  },
  {
    "objectID": "chapters/stringr.html",
    "href": "chapters/stringr.html",
    "title": "10  Strings and Character Data",
    "section": "",
    "text": "10.1 Overview\nWe introduced the concepts of strings and character vectors in Section 5.2.4.3, and we’ve worked with them a bit in the previous chapters.\nIn this chapter we’re going to dive a little deeper into character data and how to use the stringr package to manipulate and analyze strings in R.\nAs a reminder, character data is the R data type for text. Characters are the smallest units of text, like letters, numbers, and symbols. Strings are sequences of characters. Character vectors are collections of one or more strings.\nd2m-R is a character vector of length 1, containing 1 string of text: \"d2m-R\", which is a sequence of 5 characters: d, 2, m, -, and R.\nStrings and character vectors are embedded in one another. c(\"d2m\", \"-R\") is 1 character vector of length 2. The 2 strings it contains are of lengths 3 and 2, respectively. Each of those 2 strings is itself a character vector of length 1.\nIf we broke it up into it’s smallest combinatory pieces, we’d get c(\"d\", \"2\", \"m\", \"-\", \"R\"), which is a character vector of length 5 (strings), each of which is a string of length 1 (characters) and a character vector of length one. At this point the combined character vector is basically the same as the original string.\nRecall that we create strings by surrounding a string’s text in either single or double quotes, then assigning it to a variable:\nYou can use either single or double quotes to create strings in R. On your end, it’s just a matter of preference, though I recommend using double quotes for consistency.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Strings and Character Data</span>"
    ]
  },
  {
    "objectID": "chapters/stringr.html#overview",
    "href": "chapters/stringr.html#overview",
    "title": "10  Strings and Character Data",
    "section": "",
    "text": "with_single_quotes &lt;- 'This string uses single quotes.'\nwith_double_quotes &lt;- \"This string uses double quotes.\"\n\n\n10.1.1 Escaping characters\nWhat happens when you need to include a single quote in a single quoted string (or double in double)? You can do this by escaping the quote character with a backslash \\. We talked a little about escaping in Section 7.5 when we introduced regular expressions, and escaping in a string is really the same thing. When R sees the backslash, it knows to treat the next character as a literal character and part of the ongoing string rather than a functional R character. In this case, \\' or \\\" tells R that the quote should not do its usual job of ending the string.\nescaped_single_quote &lt;- 'This string uses a single quote: \\''\nescaped_double_quote &lt;- \"This string uses a double quote: \\\"\"\nOk, this is going to get weird for a minute so bear with me. Try running the code above, then view each stored variable:\nescaped_single_quote  # \"This string includes a single quote: '\"\nescaped_double_quote  # \"This string includes a double quote: \\\"\"\nIt looks like the \\ successfully escaped the single quote, but for some reason didn’t escape the double quote. But also it didn’t throw an error, it just also added the \\. Why didn’t it escape the double quote?\nWell actually, it did. What we’re intuiting here is kind of the reverse of what R is doing. R saw the escaped single quote \\' and understood you wanted to include that ' character in the string. But when R represents strings, it always uses double quotes, no matter what you told it to begin with. In this case, R saw that once it converted your single quoted string into the double-quoted string it likes better, there’s no longer a need to escape the single quote inside it. We end up with what we’d have gotten if we’d just used double quotes from the start: \"This string includes a single quote: '\".\nMeanwhile, to produce the \" character in its preferred double-quote representation, R really does need to escape it rather than do a convenient switcheroo. If we see the \\ in the output that we don’t actually want, that means R is in fact doing the escaping we want. When you view the contents of the variable by typing the variable name in the console, using print(), or looking in the Environment pane, R is showing you what the string is literally stored as. You want that escaping backslash included in the stored character data, or else R would have no way of knowing it needs to be escaped when you call it later.\nIf you want to see what the string looks like when printed, you can use the cat() function, which prints the string without the escaping characters:\ncat(escaped_single_quote)  # This string includes a single quote: '\ncat(escaped_double_quote)  # This string includes a double quote: \"\nQuote characters are likely to be the most common characters you’ll need to escape, but you can also escape other special characters that R would otherwise interpret as doing something functional. Outside of regular expressions, that usually means the backslash \\. Escaping an escape character just looks like double escaping: \\\\.\nThe escape \\ can also kind of reverse-escape. Rather than tell R that a special character should be treated as a regular old literal character in a string, escape sequences tell R that the next seemingly regular old character should be treated as a special character.\nFor example, \\n is an escape sequence for creating a new line in a string, like hitting enter/return when typing in a word processor:\nnew_line_string &lt;- \"This string has a new line.\\nSee?\"\ncat(new_line_string)  # This string has a new line.\n                       # See?\nNotice that we used cat() to print the string, rather than just typing the variable name in the console, which would show us how the string is literally stored, including \\n.\nThe other escape sequence you may find useful is \\t, which creates a tab space in a string:\ntabbed_string &lt;- \"This string has a tab.\\tSee?\"\ncat(tabbed_string)  # This string has a tab.    See?\nYNTK about escaping:\n\nIn R syntax, you can include quotes and backslashes in strings by escaping them with a backslash \\, like “\\\" or \\\\.\nIncluding \\n in a string creates a new line, and \\t creates a tab space.\nWhen you view a string variable in the console, R shows you how the string is stored, including any escaping characters. You have to use cat() to see how it will render visually.\nThese are the escape rules for strings in R. You’ll need to follow different rules in regex and markdown, but the principles are the same.\n\n\n\n10.1.2 Base R can do string stuff - Useful base R string functions\n\n10.1.2.1 paste & paste0\n\n\n10.1.2.2 c\n\n\n10.1.2.3 toupper, tolower\n\n\n10.1.2.4 is.character\n\n\n10.1.2.5 toString\n\n\n10.1.2.6 Pattern matching with grep family",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Strings and Character Data</span>"
    ]
  },
  {
    "objectID": "chapters/stringr.html#match-strings",
    "href": "chapters/stringr.html#match-strings",
    "title": "10  Strings and Character Data",
    "section": "10.2 Match strings",
    "text": "10.2 Match strings\n\n10.2.1 str_detect\n\n\n10.2.2 str_starts\n\n\n10.2.3 str_ends\n\n\n10.2.4 str_count",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Strings and Character Data</span>"
    ]
  },
  {
    "objectID": "chapters/stringr.html#subsetting-and-length",
    "href": "chapters/stringr.html#subsetting-and-length",
    "title": "10  Strings and Character Data",
    "section": "10.3 Subsetting and length",
    "text": "10.3 Subsetting and length\n\n10.3.1 str_sub\n\n\n10.3.2 str_subset\n\n\n10.3.3 str_length\n\n\n10.3.4 str_pad\n\n\n10.3.5 str_trunc\n\n\n10.3.6 str_trim",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Strings and Character Data</span>"
    ]
  },
  {
    "objectID": "chapters/stringr.html#mutate-join-split",
    "href": "chapters/stringr.html#mutate-join-split",
    "title": "10  Strings and Character Data",
    "section": "10.4 Mutate, join, split",
    "text": "10.4 Mutate, join, split\n\n10.4.1 str_sub (again)\n\n\n10.4.2 str_replace, str_replace_all\n\n\n10.4.3 str_remove, str_remove_all\n\n\n10.4.4 str_to_lower, str_to_upper, str_to_title\n\n\n10.4.5 str_split\n\n\n10.4.6 str_c, str_glue\n\n\n10.4.7 str_flatten",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Strings and Character Data</span>"
    ]
  },
  {
    "objectID": "chapters/forcats.html",
    "href": "chapters/forcats.html",
    "title": "11  forcats",
    "section": "",
    "text": "Factors variables represent discrete groups or levels. This is the word R uses for what you may prefer to call categorical, nominal, ordinal, or discrete variables (among others).\nFactor variables may not be immediately distinguishable from character variables when you look over your data, but they function very differently.\nA character variable is a string of text, and all strings are treated as unique values – even if they are identical. While R can compare two strings and determine whether they are identical:\nis_same &lt;- \"happy family\" == \"happy family\"  # TRUE\nis_different &lt;- \"unhappy family\" == \"Unhappy Family\"  # FALSE\nit won’t recognize that identical strings are meaningfully the same thing.\nLet’s say you have a survey that includes asking for respondents’ first names and favorite video games. A lot of very cool people fill out the survey, so the most common name ends up being Natalie and the most common video game is obviously Stardew Valley.\nAlthough the two variables look similar in structure on the surface given the distribution of responses, only the favorite video game variable is categorical. In a simple analysis, you might reasonably want to see the distribution of favorite video games:\nfirst_names &lt;- c(\"Natalie\", \"Lucas\", \"Natalie\", \"Jenny\", \"Middy\", \"Natalie\", \"Natalie\", \"Gabriel\")\nfavorite_games &lt;- c(\"Stardew Valley\", \"Hades\", \"Stardew Valley\", \"Celeste\", \"Stardew Valley\", \"Hades\", \"Stardew Valley\", \"Minecraft\")\n\n# create a data frame\nsurvey_data &lt;- data.frame(\n  first_name = first_names,\n  favorite_game = favorite_games\n)\n\n# view the distribution of favorite games\ntable(survey_data$favorite_game)\n\n# create a simple plot of favorite games using ggplot2\nlibrary(ggplot2)\nggplot(survey_data, aes(x = favorite_game)) +\n  geom_bar() +\n  labs(title = \"Favorite Games\", x = \"Game\", y = \"Count\")\nYou could also examine how first names are distributed, since in principle these are also discrete groups:\n# view the distribution of first names\ntable(survey_data$first_name)\n\n# create a simple plot of first names using ggplot2\n# library(ggplot2)  # already loaded above\nggplot(survey_data, aes(x = first_name)) +\n  geom_bar() +\n  labs(title = \"First Names\", x = \"Name\", y = \"Count\")\nModerately interesting if you notice you coincidentally had a lot of participants with the same name, but you’d have to some work to come up with a theoretically motivated research question that required grouping first names here.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>forcats</span>"
    ]
  },
  {
    "objectID": "chapters/basics-viz-stats.html",
    "href": "chapters/basics-viz-stats.html",
    "title": "13  Basic Visualization & Summary Statistics",
    "section": "",
    "text": "14 Chapter overview\nThis chapter is not the ggplot2 chapter or a deep stats chapter. It’s a connection between the two quarters of the class.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Basic Visualization & Summary Statistics</span>"
    ]
  },
  {
    "objectID": "chapters/basics-viz-stats.html#how-data-manipulation-in-the-tidyverse-leads-to-easier-visualization",
    "href": "chapters/basics-viz-stats.html#how-data-manipulation-in-the-tidyverse-leads-to-easier-visualization",
    "title": "13  Basic Visualization & Summary Statistics",
    "section": "15.1 how data manipulation in the tidyverse leads to easier visualization",
    "text": "15.1 how data manipulation in the tidyverse leads to easier visualization",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Basic Visualization & Summary Statistics</span>"
    ]
  },
  {
    "objectID": "chapters/basics-viz-stats.html#how-visualization-leads-to-better-understanding-of-your-data",
    "href": "chapters/basics-viz-stats.html#how-visualization-leads-to-better-understanding-of-your-data",
    "title": "13  Basic Visualization & Summary Statistics",
    "section": "15.2 how visualization leads to better understanding of your data",
    "text": "15.2 how visualization leads to better understanding of your data",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Basic Visualization & Summary Statistics</span>"
    ]
  },
  {
    "objectID": "chapters/basics-viz-stats.html#how-visualization-and-summary-statistics-fit-together",
    "href": "chapters/basics-viz-stats.html#how-visualization-and-summary-statistics-fit-together",
    "title": "13  Basic Visualization & Summary Statistics",
    "section": "15.3 how visualization and summary statistics fit together",
    "text": "15.3 how visualization and summary statistics fit together",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Basic Visualization & Summary Statistics</span>"
    ]
  },
  {
    "objectID": "chapters/basics-viz-stats.html#histograms",
    "href": "chapters/basics-viz-stats.html#histograms",
    "title": "13  Basic Visualization & Summary Statistics",
    "section": "16.1 Histograms",
    "text": "16.1 Histograms",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Basic Visualization & Summary Statistics</span>"
    ]
  },
  {
    "objectID": "chapters/basics-viz-stats.html#box-plots",
    "href": "chapters/basics-viz-stats.html#box-plots",
    "title": "13  Basic Visualization & Summary Statistics",
    "section": "16.2 Box plots",
    "text": "16.2 Box plots",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Basic Visualization & Summary Statistics</span>"
    ]
  },
  {
    "objectID": "chapters/basics-viz-stats.html#summary-statistics-mean-median-variance-standard-deviation",
    "href": "chapters/basics-viz-stats.html#summary-statistics-mean-median-variance-standard-deviation",
    "title": "13  Basic Visualization & Summary Statistics",
    "section": "16.3 Summary statistics: mean, median, variance, standard deviation",
    "text": "16.3 Summary statistics: mean, median, variance, standard deviation",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Basic Visualization & Summary Statistics</span>"
    ]
  },
  {
    "objectID": "chapters/basics-viz-stats.html#bar-plots",
    "href": "chapters/basics-viz-stats.html#bar-plots",
    "title": "13  Basic Visualization & Summary Statistics",
    "section": "17.1 Bar plots",
    "text": "17.1 Bar plots",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Basic Visualization & Summary Statistics</span>"
    ]
  },
  {
    "objectID": "chapters/basics-viz-stats.html#summary-statistics-grouped-means-medians-etc.",
    "href": "chapters/basics-viz-stats.html#summary-statistics-grouped-means-medians-etc.",
    "title": "13  Basic Visualization & Summary Statistics",
    "section": "17.2 Summary statistics: grouped means, medians, etc.",
    "text": "17.2 Summary statistics: grouped means, medians, etc.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Basic Visualization & Summary Statistics</span>"
    ]
  },
  {
    "objectID": "chapters/basics-viz-stats.html#t-tests",
    "href": "chapters/basics-viz-stats.html#t-tests",
    "title": "13  Basic Visualization & Summary Statistics",
    "section": "17.3 t-tests",
    "text": "17.3 t-tests",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Basic Visualization & Summary Statistics</span>"
    ]
  },
  {
    "objectID": "chapters/basics-viz-stats.html#more-advanced-for-later-anova-chi-squared-tests",
    "href": "chapters/basics-viz-stats.html#more-advanced-for-later-anova-chi-squared-tests",
    "title": "13  Basic Visualization & Summary Statistics",
    "section": "17.4 More advanced for later: ANOVA, chi-squared tests",
    "text": "17.4 More advanced for later: ANOVA, chi-squared tests",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Basic Visualization & Summary Statistics</span>"
    ]
  },
  {
    "objectID": "chapters/basics-viz-stats.html#scatter-plots-and-smoothing-lines",
    "href": "chapters/basics-viz-stats.html#scatter-plots-and-smoothing-lines",
    "title": "13  Basic Visualization & Summary Statistics",
    "section": "18.1 Scatter plots and smoothing lines",
    "text": "18.1 Scatter plots and smoothing lines",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Basic Visualization & Summary Statistics</span>"
    ]
  },
  {
    "objectID": "chapters/basics-viz-stats.html#correlation",
    "href": "chapters/basics-viz-stats.html#correlation",
    "title": "13  Basic Visualization & Summary Statistics",
    "section": "18.2 Correlation",
    "text": "18.2 Correlation",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Basic Visualization & Summary Statistics</span>"
    ]
  },
  {
    "objectID": "chapters/basics-viz-stats.html#basic-linear-regression",
    "href": "chapters/basics-viz-stats.html#basic-linear-regression",
    "title": "13  Basic Visualization & Summary Statistics",
    "section": "18.3 Basic linear regression",
    "text": "18.3 Basic linear regression",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Basic Visualization & Summary Statistics</span>"
    ]
  },
  {
    "objectID": "chapters/basics-viz-stats.html#more-advanced-for-later-multiple-regression-logistic-regression",
    "href": "chapters/basics-viz-stats.html#more-advanced-for-later-multiple-regression-logistic-regression",
    "title": "13  Basic Visualization & Summary Statistics",
    "section": "18.4 More advanced for later: Multiple regression, logistic regression",
    "text": "18.4 More advanced for later: Multiple regression, logistic regression",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Basic Visualization & Summary Statistics</span>"
    ]
  }
]